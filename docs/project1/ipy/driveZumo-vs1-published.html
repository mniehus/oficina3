

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Modelo de movimento diferencial com dois motores e codificadores rotacionais (um em cada lado) &mdash; oficina3  documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../../_static/copybutton.css?v=76b2166b" />
      <link rel="stylesheet" type="text/css" href="../../_static/sphinx-design.min.css?v=95c83b7e" />
      <link rel="stylesheet" type="text/css" href="../../_static/nbsphinx-code-cells.css?v=2aa19091" />

  
      <script src="../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../_static/documentation_options.js?v=5929fcd5"></script>
      <script src="../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
      <script src="../../_static/clipboard.min.js?v=a7894cd8"></script>
      <script src="../../_static/copybutton.js?v=f281be69"></script>
      <script src="../../_static/design-tabs.js?v=f930bc37"></script>
      <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
      <script>window.MathJax = {"tex": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true}, "options": {"ignoreHtmlClass": "tex2jax_ignore|mathjax_ignore|document", "processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
      <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            oficina3
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">oficina3</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../readme.html">LEFA Oficina 3 – Laboratório de Estimação e Controlo</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../readme.html#lefa-oficina-3-estimation-and-control-lab">LEFA Oficina 3 – Estimation and Control Lab</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Projeto 1</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../aeropendulum.html">Projeto 1: Aeropêndulo</a></li>
<li class="toctree-l1"><a class="reference internal" href="../analogies.html">Analogias &amp; números</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pendulum-theory.html">Aeropendulum (theory)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../motorDC-theory.html">Motor DC (theory)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../L298N.html">Modulo L298N</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fsms.html">Máquinas de Estado</a></li>
<li class="toctree-l1"><a class="reference internal" href="../interrupts.html">Interrupções</a></li>
<li class="toctree-l1"><a class="reference internal" href="../motorCalib-PT.html">Calibração &amp; software modular</a></li>
<li class="toctree-l1"><a class="reference internal" href="../as5600.html">Sensor AS5600</a></li>
<li class="toctree-l1"><a class="reference internal" href="../controlador.html">Controlador</a></li>
<li class="toctree-l1"><a class="reference internal" href="../controlo-PID-arduino.html">Controlador PID</a></li>
<li class="toctree-l1"><a class="reference internal" href="../integration.html">Integração</a></li>
<li class="toctree-l1"><a class="reference internal" href="../resultados.html">Resultados</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Projeto 2</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../project2/readme.html">Carro programável</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Project 3</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../project3/readme.html">Inverted Pendulum</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">oficina3</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">Modelo de movimento diferencial com dois motores e codificadores rotacionais (um em cada lado)</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../../_sources/project1/ipy/driveZumo-vs1-published.ipynb.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[1]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Normal python mathy code</span>
<span class="c1"># Import Libraries:</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">matplotlib.pyplot</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">plt</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">matplotlib.animation</span><span class="w"> </span><span class="kn">import</span> <span class="n">FFMpegWriter</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">matplotlib.patches</span><span class="w"> </span><span class="kn">import</span> <span class="n">Circle</span>
</pre></div>
</div>
</div>
<section id="Modelo-de-movimento-diferencial-com-dois-motores-e-codificadores-rotacionais-(um-em-cada-lado)">
<h1>Modelo de movimento diferencial com dois motores e codificadores rotacionais (um em cada lado)<a class="headerlink" href="#Modelo-de-movimento-diferencial-com-dois-motores-e-codificadores-rotacionais-(um-em-cada-lado)" title="Link to this heading"></a></h1>
<p>Para conduzir um robô de rastreio (‘tracking robot’) com dois motores (um motor à esquerda e outro à direita), controlamos a velocidade de cada roda para definir a trajetória do robô no plano $ (x, y) $. Neste tipo de robôs diferenciais, o movimento é determinado pela diferença de velocidade entre as rodas esquerda e direita.</p>
<section id="1.-Modelação-do-Movimento-do-Robô-no-Plano-$-(x,-y)-$">
<h2>1. Modelação do Movimento do Robô no Plano $ (x, y) $<a class="headerlink" href="#1.-Modelação-do-Movimento-do-Robô-no-Plano-$-(x,-y)-$" title="Link to this heading"></a></h2>
<p>Suponhamos que:</p>
<ul class="simple">
<li><p>$ v_L $ é a velocidade linear da roda esquerda,</p></li>
<li><p>$ v_R $ é a velocidade linear da roda direita,</p></li>
<li><p>$ R $ é o raio da roda,</p></li>
<li><p>$ d $ é a distância entre as rodas esquerda e direita (a base do robô).</p></li>
</ul>
</section>
<section id="2.-Velocidade-Linear-e-Rotacional-do-Robô">
<h2>2. Velocidade Linear e Rotacional do Robô<a class="headerlink" href="#2.-Velocidade-Linear-e-Rotacional-do-Robô" title="Link to this heading"></a></h2>
<p>A velocidade linear <span class="math notranslate nohighlight">\(v\)</span> do robô (no centro do eixo entre as rodas) e a velocidade angular $ :nbsphinx-math:<a href="#id1"><span class="problematic" id="id2">`</span></a>omega <a href="#id3"><span class="problematic" id="id4">`</span></a>$ (rotações por segundo) em torno do centro do robô são dadas por:</p>
<div class="math notranslate nohighlight">
\[v = \frac{v_L + v_R}{2}\]</div>
<div class="math notranslate nohighlight">
\[\omega = \frac{v_R - v_L}{d}\]</div>
</section>
<section id="3.-Equações-de-Movimento-no-Plano">
<h2>3. Equações de Movimento no Plano<a class="headerlink" href="#3.-Equações-de-Movimento-no-Plano" title="Link to this heading"></a></h2>
<p>Se o robô começa num ponto inicial $ (x_0, y_0) $ com uma orientação inicial $ <span class="math">\theta</span>_0 $ (ângulo em relação ao eixo $ x $), a posição do robô no tempo $ t $ pode ser calculada integrando a velocidade e a rotação ao longo do tempo. As equações de movimento são:</p>
<div class="math notranslate nohighlight">
\[x(t) = x_0 + \int_0^t v \cos(\theta(\tau)) \, d\tau\]</div>
<div class="math notranslate nohighlight">
\[y(t) = y_0 + \int_0^t v \sin(\theta(\tau)) \, d\tau\]</div>
<div class="math notranslate nohighlight">
\[\theta(t) = \theta_0 + \int_0^t \omega \, d\tau\]</div>
</section>
<section id="4.-Implementação-Discreta">
<h2>4. Implementação Discreta<a class="headerlink" href="#4.-Implementação-Discreta" title="Link to this heading"></a></h2>
<p>Para uma implementação discreta (em intervalos de tempo $ :nbsphinx-math:<a href="#id5"><span class="problematic" id="id6">`</span></a>Delta <a href="#id7"><span class="problematic" id="id8">`</span></a>t $), podemos aproximar estas integrais para atualizar o estado do robô em cada instante $ k $:</p>
<div class="math notranslate nohighlight">
\[x_{k+1} = x_k + v \cos(\theta_k) \Delta t\]</div>
<div class="math notranslate nohighlight">
\[y_{k+1} = y_k + v \sin(\theta_k) \Delta t\]</div>
<div class="math notranslate nohighlight">
\[\theta_{k+1} = \theta_k + \omega \Delta t\]</div>
<p>Para incorporar as medições de velocidade usando os codificadores da roda esquerda e direita, precisamos entender que a velocidade de cada roda é determinada a partir das contagens dos codificadores em intervalos de tempo específicos. Cada codificador mede o número de “pulsos” ou “contagens” que ocorrem enquanto a roda gira, o que nos permite calcular a distância percorrida por cada roda e, portanto, a velocidade.</p>
<p>Vamos supor:</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(N_L\)</span> e <span class="math notranslate nohighlight">\(N_R\)</span> são as contagens de pulsos dos codificadores da roda esquerda e da roda direita, respetivamente, durante o intervalo de tempo $ :nbsphinx-math:<a href="#id9"><span class="problematic" id="id10">`</span></a>Delta <a href="#id11"><span class="problematic" id="id12">`</span></a>t $.</p></li>
<li><p><span class="math notranslate nohighlight">\(P\)</span> é o número de impulsos por rotação completo da roda (resolução do codificador).</p></li>
<li><p><span class="math notranslate nohighlight">\(R\)</span> é o raio de cada roda.</p></li>
</ul>
<p>Para o robot Zumo, o valor de <span class="math notranslate nohighlight">\(P\)</span>, o número de impulsos por rotação completo da roda (resolução do codificador), pode ser obtido da documentação online em: <a class="reference external" href="https://www.pololu.com/docs/0J63/3.4">https://www.pololu.com/docs/0J63/3.4</a> $P = 900 CPR = 75 <span class="math">\cdot 12</span> CPR $ em que <span class="math notranslate nohighlight">\(CPR\)</span> são as contagens por revolução do eixo, <span class="math notranslate nohighlight">\(75\)</span> é o fator de redução da engrenagem mecânica entre o eixo da roda e o eixo do motor elétrico, e <span class="math notranslate nohighlight">\(12\)</span> CPR as contagens de impulsos por rotação do eixo do motor.</p>
<p>O raio da roda <span class="math notranslate nohighlight">\(R\)</span> pode ser medido ou estimado da informação disponivel, é é o raio de cada roda.</p>
<p>Em alternativa, podem determinar em laboratório qual o incremento dos contadores para cada centímetro de movimento.</p>
<p>Seja qual o método de definir estes parâmteros, eles nunca serão ‘perfeitos’, ou seja, estarão associados a uma inverteza ou um ‘erro’ que deve ser mantida tão pequeno quanto possível, no entanto, nunca poderá ser eliminado. Como se vai ver adiante, esta incerteza introduz incerteza no control do movimento e estimação de velocidade e posição.</p>
<p>A distância percorrida por cada roda durante $ <span class="math">\Delta `t $ pode ser obtida a partir da contagem de pulsos e da circunferência da roda ($ 2 :nbsphinx-math:</span>pi <cite>R $). Se $ N_L $ e $ N_R $ são as contagens de pulsos para a roda esquerda e direita, respetivamente, e $ :nbsphinx-math:</cite>Delta <cite>N_L $ e $:nbsphinx-math:</cite>Delta  <cite>N_R $ a variação das contagens desde a última medida, então a distância percorrida por cada roda ($ d_L $ para a roda esquerda e $ d_R $ para a direita) no
intervalo de temp :math:`dt</cite> é:</p>
<div class="math notranslate nohighlight">
\[\Delta d_L = \frac{\Delta N_L}{P} \cdot 2 \pi R\]</div>
<div class="math notranslate nohighlight">
\[\Delta d_R = \frac{\Delta N_R}{P} \cdot 2 \pi R\]</div>
<p>As velocidades lineares de cada roda, $ v_L $ e $ v_R $, são então dadas por:</p>
<div class="math notranslate nohighlight">
\[v_L = \frac{\Delta d_L}{\Delta t} = \frac{\Delta N_L}{P} \cdot \frac{2 \pi R}{\Delta t}\]</div>
<div class="math notranslate nohighlight">
\[v_R = \frac{\Delta d_R}{\Delta t} = \frac{\Delta N_R}{P} \cdot \frac{2 \pi R}{\Delta t}\]</div>
<p>Com as velocidades de cada roda, podemos calcular a velocidade linear do robô ($ v <span class="math notranslate nohighlight">\() e a velocidade angular (\)</span> :nbsphinx-math:<a href="#id13"><span class="problematic" id="id14">`</span></a>omega <a href="#id15"><span class="problematic" id="id16">`</span></a>$) como anteriormente:</p>
<div class="math notranslate nohighlight">
\[v = \frac{v_L + v_R}{2}\]</div>
<div class="math notranslate nohighlight">
\[\omega = \frac{v_R - v_L}{d}\]</div>
<section id="3.-Atualização-da-Posição-do-Robô-no-Plano">
<h3>3. Atualização da Posição do Robô no Plano<a class="headerlink" href="#3.-Atualização-da-Posição-do-Robô-no-Plano" title="Link to this heading"></a></h3>
<p>Agora, utilizando as expressões discretas da velocidade linear e angular, atualizamos a posição $ (x, y) $ e a orientação $ <span class="math">\theta `$ do robô em intervalos de tempo $ :nbsphinx-math:</span>Delta <a href="#id17"><span class="problematic" id="id18">`</span></a>t $:</p>
<div class="math notranslate nohighlight">
\[x_{k+1} = x_k + v \cos(\theta_k) \Delta t\]</div>
<div class="math notranslate nohighlight">
\[y_{k+1} = y_k + v \sin(\theta_k) \Delta t\]</div>
<div class="math notranslate nohighlight">
\[\theta_{k+1} = \theta_k + \omega \Delta t\]</div>
<p>Para conduzir o robô do ponto inicial ao ponto final, respeitando a orientação inicial e a orientação final desejada, podemos dividir o movimento em três etapas:</p>
<ol class="arabic simple">
<li><p><strong>Rotação Inicial</strong>: Alinhar o robô na direção do ponto final.</p></li>
<li><p><strong>Translação</strong>: Mover em linha reta até o ponto final.</p></li>
<li><p><strong>Rotação Final</strong>: Ajustar a orientação para a orientação final desejada.</p></li>
</ol>
<p>Suponhamos que:</p>
<ul class="simple">
<li><p>$ (x_0, y_0) $ e $ <span class="math">\theta</span>_0 $ representam a posição e orientação iniciais do robô.</p></li>
<li><p>$ (x_f, y_f) $ e $ <span class="math">\theta</span>_f $ representam a posição e orientação finais desejadas do robô.</p></li>
<li><p>A distância entre as rodas do robô é $ d $, e o controle é feito ajustando as velocidades angulares das rodas esquerda e direita.</p></li>
</ul>
</section>
</section>
<section id="1.-Rotação-Inicial">
<h2>1. Rotação Inicial<a class="headerlink" href="#1.-Rotação-Inicial" title="Link to this heading"></a></h2>
<p>Primeiro, precisamos alinhar o robô na direção do ponto final $ (x_f, y_f) $.</p>
<ol class="arabic">
<li><p><strong>Cálculo do Ângulo de Direção</strong>: Calcule o ângulo de orientação desejada, $ <span class="math">\theta</span>_d $, entre o ponto inicial $ (x_0, y_0) $ e o ponto final $ (x_f, y_f) $:</p>
<div class="math notranslate nohighlight">
\[\theta_d = \arctan\left(\frac{y_f - y_0}{x_f - x_0}\right)\]</div>
</li>
<li><p>**Rotação até $ <span class="math">\theta</span>_d $**: Ajuste a velocidade angular $ <span class="math">\omega `$ do robô para alinhar a orientação atual $ :nbsphinx-math:</span>theta`_0 $ com $ <span class="math">\theta</span>_d $. A rotação pode ser feita definindo as velocidades das rodas esquerda e direita, $ v_L $ e $ v_R $, com sinais opostos:</p>
<ul class="simple">
<li><p>Se $ <span class="math">\theta</span>_0 &lt; <span class="math">\theta</span>_d $, rode o robô no sentido anti-horário.</p></li>
<li><p>Se $ <span class="math">\theta</span>_0 &gt; <span class="math">\theta</span>_d $, rode o robô no sentido horário.</p></li>
</ul>
<p>A rotação é realizada com:</p>
<div class="math notranslate nohighlight">
\[v_L = -v \quad \text{e} \quad v_R = v\]</div>
<p>onde $ v $ é a velocidade desejada, de modo a gerar uma velocidade angular constante $ <span class="math">\omega `= :nbsphinx-math:</span>frac{2v}{d}` $ até que o robô atinja $ <span class="math">\theta</span>_d $.</p>
</li>
</ol>
</section>
<section id="2.-Translação-em-Linha-Reta-até-o-Ponto-Final">
<h2>2. Translação em Linha Reta até o Ponto Final<a class="headerlink" href="#2.-Translação-em-Linha-Reta-até-o-Ponto-Final" title="Link to this heading"></a></h2>
<p>Uma vez alinhado na direção do ponto final, o robô pode mover-se em linha reta até o ponto $ (x_f, y_f) $.</p>
<ol class="arabic">
<li><p><strong>Distância até o Ponto Final</strong>: Calcule a distância $ d_f $ entre a posição atual $ (x, y) $ e o ponto final $ (x_f, y_f) $:</p>
<div class="math notranslate nohighlight">
\[d_f = \sqrt{(x_f - x)^2 + (y_f - y)^2}\]</div>
</li>
<li><p><strong>Movimento em Linha Reta</strong>: Mova o robô para frente com uma velocidade linear constante $ v $ até percorrer a distância $ d_f $. Durante este movimento, a velocidade angular deve ser zero para manter o robô na linha reta:</p>
<div class="math notranslate nohighlight">
\[v_L = v \quad \text{e} \quad v_R = v\]</div>
<p>Continue o movimento até que a posição atual do robô atinja o ponto $ (x_f, y_f) $.</p>
</li>
</ol>
</section>
<section id="3.-Rotação-Final">
<h2>3. Rotação Final<a class="headerlink" href="#3.-Rotação-Final" title="Link to this heading"></a></h2>
<p>Finalmente, o robô deve ajustar a sua orientação para o ângulo final desejado $ <span class="math">\theta</span>_f $.</p>
<ol class="arabic">
<li><p><strong>Diferença de Orientação</strong>: Calcule a diferença angular $ <span class="math">\Delta `:nbsphinx-math:</span>theta <cite>$ entre a orientação atual $ :nbsphinx-math:</cite>theta <cite>$ e a orientação final $ :nbsphinx-math:</cite>theta`_f $:</p>
<div class="math notranslate nohighlight">
\[\Delta \theta = \theta_f - \theta\]</div>
</li>
<li><p>**Rotação para $ <span class="math">\theta</span>_f $**: Ajuste novamente as velocidades das rodas com sinais opostos para criar uma rotação até que a orientação atual coincida com $ <span class="math">\theta</span>_f $.</p>
<ul class="simple">
<li><p>Se $ <span class="math">\theta `< :nbsphinx-math:</span>theta`_f $, rode o robô no sentido anti-horário.</p></li>
<li><p>Se $ <span class="math">\theta `> :nbsphinx-math:</span>theta`_f $, rode o robô no sentido horário.</p></li>
</ul>
<p>A rotação final é realizada com:</p>
<div class="math notranslate nohighlight">
\[v_L = -v \quad \text{e} \quad v_R = v\]</div>
<p>até que o ângulo do robô seja igual a $ <span class="math">\theta</span>_f $.</p>
</li>
</ol>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[1]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">matplotlib.pyplot</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">plt</span>

<span class="c1"># Parâmetros do robô</span>
<span class="n">v_linear</span> <span class="o">=</span> <span class="mf">1.0</span>        <span class="c1"># Velocidade linear (m/s)</span>
<span class="n">v_angular</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">4</span>   <span class="c1"># Velocidade angular (rad/s)</span>


<span class="n">dt</span> <span class="o">=</span> <span class="mf">0.1</span>              <span class="c1"># Intervalo de tempo (s)</span>

<span class="c1"># Coordenadas e orientações iniciais e finais</span>
<span class="n">x0</span><span class="p">,</span> <span class="n">y0</span><span class="p">,</span> <span class="n">theta0</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">4</span>               <span class="c1"># Ponto inicial e orientação inicial</span>
<span class="n">xf</span><span class="p">,</span> <span class="n">yf</span><span class="p">,</span> <span class="n">thetaf</span> <span class="o">=</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">3</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">4</span>         <span class="c1"># Ponto final e orientação final</span>

<span class="c1"># Inicialização das variáveis</span>
<span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">theta</span> <span class="o">=</span> <span class="n">x0</span><span class="p">,</span> <span class="n">y0</span><span class="p">,</span> <span class="n">theta0</span>
<span class="n">trajectory_x</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">]</span>
<span class="n">trajectory_y</span> <span class="o">=</span> <span class="p">[</span><span class="n">y</span><span class="p">]</span>

<span class="c1"># 1. Rotação inicial para alinhar o robô na direção do ponto final</span>
<span class="n">theta_d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">yf</span> <span class="o">-</span> <span class="n">y0</span><span class="p">,</span> <span class="n">xf</span> <span class="o">-</span> <span class="n">x0</span><span class="p">)</span>
<span class="k">while</span> <span class="nb">abs</span><span class="p">(</span><span class="n">theta</span> <span class="o">-</span> <span class="n">theta_d</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">0.01</span><span class="p">:</span>  <span class="c1"># Até atingir a orientação desejada</span>
    <span class="k">if</span> <span class="n">theta</span> <span class="o">&lt;</span> <span class="n">theta_d</span><span class="p">:</span>
        <span class="n">theta</span> <span class="o">+=</span> <span class="n">v_angular</span> <span class="o">*</span> <span class="n">dt</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">theta</span> <span class="o">-=</span> <span class="n">v_angular</span> <span class="o">*</span> <span class="n">dt</span>
    <span class="n">trajectory_x</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">trajectory_y</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>

<span class="c1"># 2. Translação em linha reta até o ponto final</span>
<span class="n">distance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">xf</span> <span class="o">-</span> <span class="n">x</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">yf</span> <span class="o">-</span> <span class="n">y</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
<span class="k">while</span> <span class="n">distance</span> <span class="o">&gt;</span> <span class="mf">0.1</span><span class="p">:</span>  <span class="c1"># Até atingir o ponto final</span>
    <span class="n">x</span> <span class="o">+=</span> <span class="n">v_linear</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span> <span class="o">*</span> <span class="n">dt</span>
    <span class="n">y</span> <span class="o">+=</span> <span class="n">v_linear</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span> <span class="o">*</span> <span class="n">dt</span>
    <span class="n">distance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">xf</span> <span class="o">-</span> <span class="n">x</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">yf</span> <span class="o">-</span> <span class="n">y</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">trajectory_x</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">trajectory_y</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>

<span class="c1"># 3. Rotação final para atingir a orientação final desejada</span>
<span class="k">while</span> <span class="nb">abs</span><span class="p">(</span><span class="n">theta</span> <span class="o">-</span> <span class="n">thetaf</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">0.01</span><span class="p">:</span>  <span class="c1"># Até atingir a orientação final</span>
    <span class="k">if</span> <span class="n">theta</span> <span class="o">&lt;</span> <span class="n">thetaf</span><span class="p">:</span>
        <span class="n">theta</span> <span class="o">+=</span> <span class="n">v_angular</span> <span class="o">*</span> <span class="n">dt</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">theta</span> <span class="o">-=</span> <span class="n">v_angular</span> <span class="o">*</span> <span class="n">dt</span>
    <span class="n">trajectory_x</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">trajectory_y</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>

<span class="c1"># Plot da trajetória</span>
<span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">8</span><span class="p">))</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">trajectory_x</span><span class="p">,</span> <span class="n">trajectory_y</span><span class="p">,</span> <span class="s1">&#39;-o&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Trajetória do robô&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">([</span><span class="n">x0</span><span class="p">,</span> <span class="n">xf</span><span class="p">],</span> <span class="p">[</span><span class="n">y0</span><span class="p">,</span> <span class="n">yf</span><span class="p">],</span> <span class="s1">&#39;rx&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Pontos inicial e final&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">arrow</span><span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="n">y0</span><span class="p">,</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta0</span><span class="p">),</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta0</span><span class="p">),</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;blue&quot;</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="mf">0.05</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Orientação inicial&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">arrow</span><span class="p">(</span><span class="n">xf</span><span class="p">,</span> <span class="n">yf</span><span class="p">,</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">thetaf</span><span class="p">),</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">thetaf</span><span class="p">),</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;green&quot;</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="mf">0.05</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Orientação final&quot;</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;x (m)&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;y (m)&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&quot;Simulação do Movimento do Robô&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s2">&quot;equal&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
<br/></pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<img alt="../../_images/project1_ipy_driveZumo-vs1-published_3_0.png" src="../../_images/project1_ipy_driveZumo-vs1-published_3_0.png" />
</div>
</div>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[ ]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>
</pre></div>
</div>
</div>
</section>
</section>


           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, mniehus.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>