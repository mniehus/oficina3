

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>[EN] State-Machines applied to DC Motor Calibration &mdash; oficina3  documentation</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../_static/copybutton.css?v=76b2166b" />
      <link rel="stylesheet" type="text/css" href="../_static/sphinx-design.min.css?v=95c83b7e" />

  
      <script src="../_static/jquery.js?v=5d32c60e"></script>
      <script src="../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../_static/documentation_options.js?v=5929fcd5"></script>
      <script src="../_static/doctools.js?v=9bcbadda"></script>
      <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
      <script src="../_static/clipboard.min.js?v=a7894cd8"></script>
      <script src="../_static/copybutton.js?v=f281be69"></script>
      <script src="../_static/design-tabs.js?v=f930bc37"></script>
      <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
      <script type="module" src="https://cdn.jsdelivr.net/npm/mermaid@11.2.0/dist/mermaid.esm.min.mjs"></script>
      <script type="module" src="https://cdn.jsdelivr.net/npm/@mermaid-js/layout-elk@0.1.4/dist/mermaid-layout-elk.esm.min.mjs"></script>
      <script type="module">import mermaid from "https://cdn.jsdelivr.net/npm/mermaid@11.2.0/dist/mermaid.esm.min.mjs";import elkLayouts from "https://cdn.jsdelivr.net/npm/@mermaid-js/layout-elk@0.1.4/dist/mermaid-layout-elk.esm.min.mjs";mermaid.registerLayoutLoaders(elkLayouts);mermaid.initialize({startOnLoad:false});</script>
      <script src="https://cdn.jsdelivr.net/npm/d3@7.9.0/dist/d3.min.js"></script>
      <script type="module">
import mermaid from "https://cdn.jsdelivr.net/npm/mermaid@11.2.0/dist/mermaid.esm.min.mjs";
window.addEventListener("load", () => mermaid.run());
</script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html" class="icon icon-home">
            oficina3
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">oficina3</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../readme.html">LEFA Oficina 3 – Laboratório de Estimação e Controlo</a></li>
<li class="toctree-l1"><a class="reference internal" href="../readme.html#lefa-oficina-3-estimation-and-control-lab">LEFA Oficina 3 – Estimation and Control Lab</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Projeto 1</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="aeropendulum.html">Projeto 1: Aeropêndulo</a></li>
<li class="toctree-l1"><a class="reference internal" href="analogies.html">Analogias &amp; números</a></li>
<li class="toctree-l1"><a class="reference internal" href="pendulum-theory.html">Aeropendulum (theory)</a></li>
<li class="toctree-l1"><a class="reference internal" href="motorDC-theory.html">Motor DC (theory)</a></li>
<li class="toctree-l1"><a class="reference internal" href="L298N.html">Modulo L298N</a></li>
<li class="toctree-l1"><a class="reference internal" href="fsms.html">Máquinas de Estado</a></li>
<li class="toctree-l1"><a class="reference internal" href="interrupts.html">Interrupções</a></li>
<li class="toctree-l1"><a class="reference internal" href="motorCalib-PT.html">Calibração &amp; software modular</a></li>
<li class="toctree-l1"><a class="reference internal" href="as5600.html">Sensor AS5600</a></li>
<li class="toctree-l1"><a class="reference internal" href="controlador.html">Controlador</a></li>
<li class="toctree-l1"><a class="reference internal" href="controlo-PID-arduino.html">Controlador PID</a></li>
<li class="toctree-l1"><a class="reference internal" href="integration.html">Integração</a></li>
<li class="toctree-l1"><a class="reference internal" href="resultados.html">Resultados</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Projeto 2</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../project2/readme.html">Carro programável</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Project 3</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../project3/readme.html">Inverted Pendulum</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">oficina3</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">[EN] State-Machines applied to DC Motor Calibration</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/project1/motorCalib-EN.md.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section class="tex2jax_ignore mathjax_ignore" id="en-state-machines-applied-to-dc-motor-calibration">
<h1>[EN] State-Machines applied to DC Motor Calibration<a class="headerlink" href="#en-state-machines-applied-to-dc-motor-calibration" title="Link to this heading"></a></h1>
<p>This document is an <strong>intro + guide</strong> to the project of the DC Motor Calibration Automated Test Setup.</p>
<p>The project automates a <strong>speed–voltage calibration</strong> for a small DC propulsion unit. An Arduino generates a configurable <strong>PWM (=pulse width modulation) ramp TTL signal</strong> that drives an H-bridge motor driver, which powers a <strong>3.7 V drone DC motor</strong> with a <strong>two-blade propeller</strong>. The motor sits in a simple rig with an <strong>optical slot sensor</strong> acting as an incremental encoder: each blade crossing produces a pulse used to infer <strong>rotational speed RPM (=rotations per minute)</strong>. Test parameters—ramp maximum, duration, step/cadence—are set in software so the same bench hardware can run many repeatable sweeps.</p>
<p>During a run, the PWM ramp and the RPM measurements are <strong>synchronized</strong>: PWM updates define clean timing windows over which pulses are counted and converted to RPM (or, alternatively, a fixed sampling period can be used). After each measurement, the system streams <strong>tab-separated values (TSV)</strong> over the USB serial link—time, commanded waveform value, applied PWM, and RPM—so the user can copy-paste straight into Excel (or any spreadsheet) for plotting and further analysis.</p>
<p>The <strong>hardware part</strong> is simple. A <strong>PC</strong> connects over <strong>USB</strong> to an <strong>Arduino board</strong> (e.g., Arduino Uno). One <strong>PWM-capable digital pin</strong> on the Arduino feeds the <strong>H-bridge DC motor driver’s enable/PWM input</strong>.</p>
<p>The H-bridge board is powered by a <strong>bench DC supply</strong> (set to the motor’s rated voltage/current) and drives a <strong>3.7 V mini drone DC motor</strong> fitted with a <strong>two-blade propeller</strong>. Verify that voltage–current operating points during the calibration ramp are not limited by the DC supply (current limit/sag), especially at high speed/high load.</p>
<p>An <strong>optical slot sensor</strong> (IR LED + phototransistor) is mounted in a small mechanical setup so each blade interrupts the beam once per revolution half-turn, producing two clean pulses per revolution. Use the slot sensor board’s LED indicators to align the blades for a clean RPM signal, and prefer the sensor’s digital output over the analog output. The sensor output connects to an <strong>Arduino interrupt pin</strong> (e.g., D2) for accurate pulse counting.</p>
<p>Logic grounds are commoned: Arduino GND ↔ driver logic GND ↔ sensor GND. The motor power supply is separated from the logic power supply, which stays tied at the driver. Power the motor from the bench supply and the Arduino from USB to reduce coupling; the H-bridge’s internal diodes handle flyback.</p>
<p>For real time observation, use two scope test points: the <strong>PWM signal</strong> (Arduino → driver enable) and the <strong>RPM pulse signal</strong> (sensor → Arduino interrupt). View duty and pulse timing on an oscilloscope while the Arduino simultaneously uses them (drive and measure).</p>
<p>For user input, a <strong>pushbutton</strong>, a <strong>potentiometer (knob)</strong>, and the <strong>USB serial interface</strong> can be considered for future use. Also, for user output, <strong>three RGB LEDs</strong> for visual feedback and a <strong>piezo buzzer</strong> for acoustic signalling/sound feedback can be used. These are included for completeness here; however, their use in the current project is optional, but they can be handy to implement simple user interfaces here or in other projects.</p>
<p>The <strong>software part</strong> is organized into six small independent tasks, through modules that are coded as  <strong>finite state machines (FSMs)</strong>.</p>
<p>This system is an <strong>experimental test ground for academic training</strong>. While the automated DC motor calibration could be implemented more simply, the goal is to introduce and consolidate a <strong>reusable, modular FSM framework</strong> that is scalable and easy to adapt to future projects.</p>
<p>It’s meant to teach students how FSMs work, how to implement and test them, to understand why we use FSMs, and show that the code is reusable and scalablable, that it stays clear and tidy as the system grows (no spaghetti!), and how the modules are integrated into a system, and how they can interact via a small set of shared globals.</p>
<hr class="docutils" />
<section id="why-state-machines">
<h2>Why State Machines?<a class="headerlink" href="#why-state-machines" title="Link to this heading"></a></h2>
<p><strong>The problem:</strong> embedded systems juggle multiple tasks—waveform generation, PWM output, RPM measurement, logging, user I/O—often with different cadences and hardware constraints. Naive loops with delays quickly become unmanageable.</p>
<p><strong>State machines</strong> solve this by:</p>
<ul class="simple">
<li><p><strong>Modularity:</strong> each feature lives in its own file/function with its own states, timers, and config; no spaghetti delays.</p></li>
<li><p><strong>Testability:</strong> each FSM can be exercised in isolation (e.g., force states or inject inputs) and verified.</p></li>
<li><p><strong>Determinism:</strong> all FSMs are <strong>non-blocking</strong> and run every loop; timing is explicit (period checks), not implicit (<code class="docutils literal notranslate"><span class="pre">delay()</span></code>).</p></li>
<li><p><strong>Extensibility:</strong> add a state or transition without rewriting unrelated parts.</p></li>
<li><p><strong>Low cross coupling:</strong> modules “talk” only through a few <strong>shared global signals</strong> (bytes, floats, counters), not through deep call chains.</p></li>
<li><p><strong>Usability:</strong> the behavior of each module is easy to explain with a simple <strong>UML state chart</strong>.</p></li>
</ul>
</section>
<hr class="docutils" />
<section id="software-layout">
<h2>Software layout<a class="headerlink" href="#software-layout" title="Link to this heading"></a></h2>
<p>The software layout follows a <strong>modular state-machine architecture</strong>: every essential task runs <strong>non-blocking</strong> in its own finite state machine (FSM), coded in a <strong>separate, reusable file</strong>. Each FSM keeps its own local configuration (as <code class="docutils literal notranslate"><span class="pre">const</span></code> inside the function), uses internal state to handle timing (no <code class="docutils literal notranslate"><span class="pre">delay()</span></code>), and communicates only through a few shared global signals. The <strong>Arduino controller file</strong> in the same folder configures the interrupt(s), declares the shared globals, and assembles the system by calling all FSMs in <code class="docutils literal notranslate"><span class="pre">loop()</span></code>.</p>
<p><strong>Controller file</strong></p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">MotorCalib</span><span class="p">.</span><span class="n">ino</span><span class="w">                  </span><span class="c1">// controller, globals, interrupt config, empty setup(), loop() calling all FSMs</span>
</pre></div>
</div>
<p><strong>FSM Modules</strong></p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">WaveformFSM</span><span class="p">.</span><span class="n">ino</span><span class="w">                 </span><span class="c1">// WaveformFSM_update()</span>
<span class="n">PWMOutputFSM</span><span class="p">.</span><span class="n">ino</span><span class="w">                </span><span class="c1">// PWMOutputFSM_update()</span>
<span class="n">RPM_FSM</span><span class="p">.</span><span class="n">ino</span><span class="w">                     </span><span class="c1">// RPM_FSM_update()</span>
<span class="n">DataLogger_FSM</span><span class="p">.</span><span class="n">ino</span><span class="w">           </span><span class="c1">// UnifiedLogger_FSM_update(...)</span>
<span class="n">UserInput_FSM</span><span class="p">.</span><span class="n">ino</span><span class="w">               </span><span class="c1">// UserInput_FSM_update()</span>
<span class="n">UserOutput_FSM</span><span class="p">.</span><span class="n">ino</span><span class="w">              </span><span class="c1">// UserOutput_FSM_update()</span>
</pre></div>
</div>
<ul class="simple">
<li><p><strong>Waveform FSM</strong>: Generates a sample stream (sine / square / sawtooth / single ramp) at a configured sample period and modulation period; writes <code class="docutils literal notranslate"><span class="pre">sig_waveform_value</span></code>.</p></li>
<li><p><strong>PWM Output FSM</strong>: Periodically applies <code class="docutils literal notranslate"><span class="pre">sig_waveform_value</span></code> to the PWM pin with clamp, optional minimum, and <strong>slew limiter</strong>; writes <code class="docutils literal notranslate"><span class="pre">sig_pwm_applied</span></code> and increments <code class="docutils literal notranslate"><span class="pre">sig_pwm_update_counter</span></code> each update.</p></li>
<li><p><strong>RPM FSM</strong>: Counts optical encoder pulses (from ISR) and computes RPM either on a <strong>fixed period</strong> or <strong>synchronized</strong> to PWM windows using <code class="docutils literal notranslate"><span class="pre">sig_pwm_update_counter</span></code>; writes <code class="docutils literal notranslate"><span class="pre">sig_rpm</span></code>.</p></li>
<li><p><strong>Data Logger FSM</strong>: One logger with two modes—<strong>free-run</strong> (fixed cadence) or <strong>PWM-synchronized</strong>—printing selected columns (time, waveform, PWM, RPM) as TSV.</p></li>
<li><p><strong>User Input FSM</strong>: Debounces a pushbutton, samples a potentiometer, and parses simple serial <strong>key=value</strong> commands; writes <code class="docutils literal notranslate"><span class="pre">sig_input_*</span></code>.</p></li>
<li><p><strong>User Output FSM</strong>: Drives RGB LEDs and a piezo via <code class="docutils literal notranslate"><span class="pre">tone()</span></code> (continuous or timed) or digital toggling; consumes <code class="docutils literal notranslate"><span class="pre">sig_led_*</span></code> and <code class="docutils literal notranslate"><span class="pre">sig_buzzer_*</span></code>.</p></li>
</ul>
<p><strong>How do the parts come together?</strong></p>
<ol class="arabic simple">
<li><p><strong>Waveform → PWM:</strong> The Waveform FSM produces a <strong>desired duty</strong> (<code class="docutils literal notranslate"><span class="pre">sig_waveform_value</span></code>).</p></li>
<li><p><strong>PWM applies (with safety):</strong> PWM FSM clamps, optionally lifts small values, and <strong>slew-limits</strong> before writing the pin. It also increments <code class="docutils literal notranslate"><span class="pre">sig_pwm_update_counter</span></code> on each update.</p></li>
<li><p><strong>RPM sampling:</strong> RPM FSM measures pulses either on a fixed period or <strong>in sync with PWM windows</strong> (edge-to-edge), then writes <code class="docutils literal notranslate"><span class="pre">sig_rpm</span></code>.</p></li>
<li><p><strong>Logging:</strong> Data Logger prints TSV lines either periodically or per PWM window, with selectable columns for <strong>time / waveform / PWM / RPM</strong>.</p></li>
<li><p><strong>User input/output:</strong> The User Input FSM updates <code class="docutils literal notranslate"><span class="pre">sig_input_*</span></code> from the <strong>button, pot, and serial</strong>. <code class="docutils literal notranslate"><span class="pre">sig_led_*</span></code> and the buzzer signals are also globally declared, and are driven by User Output FSM. Any state machine can access them.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">MotorCalib.ino</span></code> is the “composer”: it declares the <strong>shared global variables</strong>, configures and attaches the <strong>encoder ISR</strong>, leaves <code class="docutils literal notranslate"><span class="pre">setup()</span></code> empty (FSMs self-init on first call), and in <code class="docutils literal notranslate"><span class="pre">loop()</span></code> calls the FSMs in order, e.g.
<code class="docutils literal notranslate"><span class="pre">Waveform</span> <span class="pre">→</span> <span class="pre">PWM</span> <span class="pre">Output</span> <span class="pre">→</span> <span class="pre">RPM</span> <span class="pre">→</span> <span class="pre">Datalogger</span> <span class="pre">→</span> <span class="pre">User</span> <span class="pre">Input</span> <span class="pre">→</span> <span class="pre">User</span> <span class="pre">Output</span></code>.</p></li>
<li><p>Each FSM is <strong>non-blocking</strong> and advances via timers and <code class="docutils literal notranslate"><span class="pre">switch(state)</span></code>; they read/write only the documented globals, so files remain independent and reusable across projects.</p></li>
</ol>
</section>
<section id="tips-for-labs-testing">
<h2>Tips for Labs &amp; Testing<a class="headerlink" href="#tips-for-labs-testing" title="Link to this heading"></a></h2>
<ul class="simple">
<li><p><strong>Single-module tests:</strong> Comment out others and run one FSM at a time; use the Logger in free-run mode to watch behavior.</p></li>
<li><p><strong>Traceability:</strong> Each FSM’s header in code documents details <strong>task, inputs (signals), outputs (signals), usage, tests, and how to extend</strong>— explore and study the information in each module.</p></li>
<li><p><strong>Implement the use case:</strong> Set Waveform to <strong>SINGLE_RAMP</strong> (no repeat) to capture a full PWM→RPM calibration sweep.</p></li>
</ul>
</section>
<hr class="docutils" />
<section id="annex-1-full-reference-code-base">
<h2>Annex 1: Full reference code base<a class="headerlink" href="#annex-1-full-reference-code-base" title="Link to this heading"></a></h2>
<p>The full reference code base is available for download for course participants on the courses moodle platform, pls check.</p>
</section>
<section id="annex-2-calibration-controller">
<h2>Annex 2: Calibration Controller<a class="headerlink" href="#annex-2-calibration-controller" title="Link to this heading"></a></h2>
<p>The <strong>calibration controller</strong>  Arduino file <code class="docutils literal notranslate"><span class="pre">motorCalib.ino</span></code> is the project’s orchestration point. It <strong>owns the shared signals</strong> (simple global variables), <strong>defines the encoder ISR</strong>, and <strong>runs all finite-state machines (FSMs) once per loop</strong> in a fixed, non-blocking order. Each FSM keeps its own local configuration and internal timing; the controller only wires them together through a few globals.</p>
<p><strong>Tasks</strong></p>
<ul class="simple">
<li><p><strong>Shared globals:</strong> declare the small set of cross-module variables (e.g., <code class="docutils literal notranslate"><span class="pre">sig_waveform_value</span></code>, <code class="docutils literal notranslate"><span class="pre">sig_pwm_applied</span></code>, <code class="docutils literal notranslate"><span class="pre">sig_pwm_update_counter</span></code>, <code class="docutils literal notranslate"><span class="pre">sig_encoder_pulses</span></code>, <code class="docutils literal notranslate"><span class="pre">sig_rpm</span></code>, user I/O and output intents).</p></li>
<li><p><strong>Interrupt ownership:</strong> define the <strong>ISR</strong> (increments <code class="docutils literal notranslate"><span class="pre">volatile</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">sig_encoder_pulses</span></code>) and the <strong>encoder pin</strong>. The <strong>attach/detach</strong> is performed by the RPM FSM during its <code class="docutils literal notranslate"><span class="pre">INIT</span></code> state (single source of truth for mode/edge), while the controller remains the canonical place for the ISR symbol and counter.</p></li>
<li><p><strong>Execution model:</strong> cooperative, <strong>non-blocking</strong> scheduling—every FSM is called once per <code class="docutils literal notranslate"><span class="pre">loop()</span></code>. Each FSM advances via timers/guards (no <code class="docutils literal notranslate"><span class="pre">delay()</span></code>), so tasks interleave predictably.</p></li>
<li><p><strong>Call order (establishes data flow):</strong>
<code class="docutils literal notranslate"><span class="pre">Waveform</span> <span class="pre">→</span> <span class="pre">PWM</span> <span class="pre">Output</span> <span class="pre">→</span> <span class="pre">RPM</span> <span class="pre">→</span> <span class="pre">Datalogger</span> <span class="pre">→</span> <span class="pre">User</span> <span class="pre">Input</span> <span class="pre">→</span> <span class="pre">User</span> <span class="pre">Output</span></code>.
This ordering ensures:</p>
<ul>
<li><p>PWM reads the latest waveform sample.</p></li>
<li><p>RPM can <strong>couple</strong> its measurement window to PWM updates via <code class="docutils literal notranslate"><span class="pre">sig_pwm_update_counter</span></code>.</p></li>
<li><p>The Datalogger prints values computed <strong>this</strong> cycle.</p></li>
<li><p>User input/output are applied every cycle without blocking others.</p></li>
</ul>
</li>
</ul>
<p><strong>Timing &amp; determinism</strong></p>
<ul class="simple">
<li><p>All timing is <strong>explicit</strong> (period checks inside each FSM). Loop frequency can vary; behavior does not.</p></li>
<li><p>The only asynchronous source is the <strong>encoder ISR</strong>; access its counter with <code class="docutils literal notranslate"><span class="pre">volatile</span></code> and brief critical sections (already handled inside the RPM FSM).</p></li>
</ul>
<p><strong>Code:</strong>   <a class="reference download internal" download="" href="../_downloads/526e5112078a99e1d8169c9ab9470d84/motorCalib.ino"><span class="xref download myst">motorCalib.ino</span></a></p>
</section>
<section id="annex-3-global-signals">
<h2>Annex 3: Global signals<a class="headerlink" href="#annex-3-global-signals" title="Link to this heading"></a></h2>
<p>These are the only cross-module variables. Each FSM <strong>reads</strong> and/or <strong>writes</strong> them.</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Signal</p></th>
<th class="head"><p>Type</p></th>
<th class="head"><p>Producer(s)</p></th>
<th class="head"><p>Consumer(s)</p></th>
<th class="head"><p>Meaning</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">sig_waveform_value</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">byte</span></code></p></td>
<td><p>Waveform FSM</p></td>
<td><p>PWM Output, Logger</p></td>
<td><p>Desired duty sample (0..255)</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">sig_pwm_applied</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">byte</span></code></p></td>
<td><p>PWM Output</p></td>
<td><p>Logger</p></td>
<td><p>Actually written PWM (0..255)</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">sig_pwm_update_counter</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span></code></p></td>
<td><p>PWM Output</p></td>
<td><p>RPM FSM, Logger</p></td>
<td><p>Increments each time PWM is updated</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">sig_encoder_pulses</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">volatile</span> <span class="pre">unsigned</span> <span class="pre">long</span></code></p></td>
<td><p><strong>ISR</strong></p></td>
<td><p>RPM FSM</p></td>
<td><p>Rising-edge pulse counter from slot sensor</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">sig_rpm</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">float</span></code></p></td>
<td><p>RPM FSM</p></td>
<td><p>Logger</p></td>
<td><p>Latest RPM estimate</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">sig_input_button</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">byte</span></code></p></td>
<td><p>User Input</p></td>
<td><p>Any</p></td>
<td><p>Debounced button (0/1)</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">sig_input_pot</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">int</span></code></p></td>
<td><p>User Input</p></td>
<td><p>Any</p></td>
<td><p>Potentiometer ADC (0..1023)</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">sig_input_key</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">char</span></code></p></td>
<td><p>User Input</p></td>
<td><p>Any</p></td>
<td><p>Last serial key</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">sig_input_value</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">long</span></code></p></td>
<td><p>User Input</p></td>
<td><p>Any</p></td>
<td><p>Last serial value</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">sig_input_has_cmd</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">bool</span></code></p></td>
<td><p>User Input</p></td>
<td><p>Any</p></td>
<td><p>Latched “new command available”</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">sig_led_r/g/b</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">byte</span></code></p></td>
<td><p>Any</p></td>
<td><p>User Output</p></td>
<td><p>RGB LED on/off commands</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">sig_buzzer_tone_enable</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">bool</span></code></p></td>
<td><p>Any</p></td>
<td><p>User Output</p></td>
<td><p>Use <code class="docutils literal notranslate"><span class="pre">tone()</span></code> if true</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">sig_buzzer_tone_freq_hz</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span></code></p></td>
<td><p>Any</p></td>
<td><p>User Output</p></td>
<td><p>Tone frequency</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">sig_buzzer_tone_ms</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span></code></p></td>
<td><p>Any</p></td>
<td><p>User Output</p></td>
<td><p>0=continuous, else one-shot duration</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">sig_buzzer_toggle_enable</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">bool</span></code></p></td>
<td><p>Any</p></td>
<td><p>User Output</p></td>
<td><p>Use digital toggling if true and tone disabled</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">sig_buzzer_toggle_period_ms</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span></code></p></td>
<td><p>Any</p></td>
<td><p>User Output</p></td>
<td><p>Half-period for toggling</p></td>
</tr>
</tbody>
</table>
</section>
<hr class="docutils" />
<section id="annex-4-fsm-modules-explained">
<h2>Annex 4: FSM modules explained<a class="headerlink" href="#annex-4-fsm-modules-explained" title="Link to this heading"></a></h2>
<p>Below is a UML (unified model language) diagram by FSM (states and transitions).
Note the strict correspondence between the diagram and the code.</p>
<p>The list is started with a generic, educative example of a reference FSM, and then followed by the detailed description of the FSMs used.</p>
<section id="reference-fsm-generic-example">
<h3>Reference FSM (generic example)<a class="headerlink" href="#reference-fsm-generic-example" title="Link to this heading"></a></h3>
<p><strong>Task:</strong> este exemplo <strong>genérico</strong> de máquina de estados com três estados — <code class="docutils literal notranslate"><span class="pre">INIT</span></code>, <code class="docutils literal notranslate"><span class="pre">STATE1</span></code>, <code class="docutils literal notranslate"><span class="pre">STATE2</span></code> — ilustra um ciclo típico: inicializar, operar num primeiro modo, alternar para um segundo modo mediante um evento/condição, e regressar.</p>
<pre  class="mermaid">
        stateDiagram-v2
  [*] --&gt; INIT
  INIT --&gt; STATE1 : event/condition_1 (p.ex., &quot;inicialização concluída&quot;)
  STATE1 --&gt; STATE2 : event/condition_2 (p.ex., &quot;temporizador1 expirou&quot; OU &quot;botão premido&quot;)
  STATE1 --&gt; STATE1 : else (permanece até ocorrer event/condition_2)
  STATE2 --&gt; STATE1 : event/condition_3 (p.ex., &quot;temporizador2 expirou&quot; OU &quot;valor abaixo do limiar&quot;)
  STATE2 --&gt; STATE2 : else (permanece até ocorrer event/condition_3)
    </pre><p><strong>Events/transition conditions:</strong></p>
<ul class="simple">
<li><p>event/condition_1: sistema pronto (ex.: configuração feita).</p></li>
<li><p>event/condition_2: condição para mudar de <code class="docutils literal notranslate"><span class="pre">STATE1</span></code> para <code class="docutils literal notranslate"><span class="pre">STATE2</span></code> (ex.: temporizador1, entrada externa, limiar atingido).</p></li>
<li><p>event/condition_3: condição para regressar de <code class="docutils literal notranslate"><span class="pre">STATE2</span></code> para <code class="docutils literal notranslate"><span class="pre">STATE1</span></code> (ex.: temporizador2, entrada externa, limiar desfeito).</p></li>
</ul>
<p><strong>Activities:</strong></p>
<ul class="simple">
<li><p>INIT: preparar variáveis/recursos; marcar sistema como pronto.</p></li>
<li><p>STATE1: executar atividade A (ex.: atualizar saída/monitorizar entrada com período T1).</p></li>
<li><p>STATE2: executar atividade B (ex.: outra estratégia/saída com período T2).</p></li>
</ul>
<p><strong>Code</strong> (Arduino/C++; não bloqueante, educativo)</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// ---------------- Optional shared signal for demos ----------------</span>
<span class="n">byte</span><span class="w"> </span><span class="n">sig_ref_state</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">  </span><span class="c1">// 0=INIT, 1=STATE1, 2=STATE2</span>

<span class="c1">// ---------------- Three-state reference FSM ----------------------</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">ReferenceFSM_update</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// -------- Local configuration constants (tunable) --------------</span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w">  </span><span class="n">PERIOD_STATE1_MS</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">250</span><span class="p">;</span><span class="w">   </span><span class="c1">// drives event/condition_2 (example)</span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w">  </span><span class="n">PERIOD_STATE2_MS</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">500</span><span class="p">;</span><span class="w">   </span><span class="c1">// drives event/condition_3 (example)</span>

<span class="w">  </span><span class="c1">// -------- Local state constants (UPPERCASE) --------------------</span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">byte</span><span class="w"> </span><span class="n">INIT</span><span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">byte</span><span class="w"> </span><span class="n">STATE1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">byte</span><span class="w"> </span><span class="n">STATE2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// -------- Local static variables -------------------------------</span>
<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="n">byte</span><span class="w">          </span><span class="n">state</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">INIT</span><span class="p">;</span>
<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">t1_ms</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">   </span><span class="c1">// timer for STATE1</span>
<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">t2_ms</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">   </span><span class="c1">// timer for STATE2</span>
<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="kt">bool</span><span class="w">          </span><span class="n">ready</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span><span class="w"> </span><span class="c1">// models event/condition_1</span>

<span class="w">  </span><span class="c1">// -------- Time base --------------------------------------------</span>
<span class="w">  </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">now</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">millis</span><span class="p">();</span>

<span class="w">  </span><span class="c1">// -------- FSM ---------------------------------------------------</span>
<span class="w">  </span><span class="k">switch</span><span class="w"> </span><span class="p">(</span><span class="n">state</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>

<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="no">INIT</span><span class="p">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="c1">// Activities: initialize resources/vars</span>
<span class="w">      </span><span class="n">ready</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span><span class="w">                  </span><span class="c1">// event/condition_1 satisfied</span>
<span class="w">      </span><span class="n">sig_ref_state</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>

<span class="w">      </span><span class="c1">// Transition: INIT -&gt; STATE1 on event/condition_1</span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">ready</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">t1_ms</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">now</span><span class="p">;</span><span class="w">                 </span><span class="c1">// reset STATE1 timer</span>
<span class="w">        </span><span class="n">state</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">STATE1</span><span class="p">;</span>
<span class="w">      </span><span class="p">}</span>
<span class="w">      </span><span class="k">break</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="no">STATE1</span><span class="p">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="c1">// Activities: do-A (periodic action at PERIOD_STATE1_MS)</span>
<span class="w">      </span><span class="n">sig_ref_state</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>

<span class="w">      </span><span class="c1">// Example periodic activity (replace with your own):</span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">((</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="p">)(</span><span class="n">now</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">t1_ms</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">PERIOD_STATE1_MS</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// --- event/condition_2 occurs here (e.g., timer1 expired) ---</span>
<span class="w">        </span><span class="n">t2_ms</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">now</span><span class="p">;</span><span class="w">                 </span><span class="c1">// prepare STATE2 timer</span>
<span class="w">        </span><span class="n">state</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">STATE2</span><span class="p">;</span><span class="w">              </span><span class="c1">// Transition: STATE1 -&gt; STATE2</span>
<span class="w">      </span><span class="p">}</span>
<span class="w">      </span><span class="c1">// else: remain in STATE1</span>
<span class="w">      </span><span class="k">break</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="no">STATE2</span><span class="p">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="c1">// Activities: do-B (periodic action at PERIOD_STATE2_MS)</span>
<span class="w">      </span><span class="n">sig_ref_state</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>

<span class="w">      </span><span class="c1">// Example periodic activity (replace with your own):</span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">((</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="p">)(</span><span class="n">now</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">t2_ms</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">PERIOD_STATE2_MS</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// --- event/condition_3 occurs here (e.g., timer2 expired) ---</span>
<span class="w">        </span><span class="n">t1_ms</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">now</span><span class="p">;</span><span class="w">                 </span><span class="c1">// prepare STATE1 timer</span>
<span class="w">        </span><span class="n">state</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">STATE1</span><span class="p">;</span><span class="w">              </span><span class="c1">// Transition: STATE2 -&gt; STATE1</span>
<span class="w">      </span><span class="p">}</span>
<span class="w">      </span><span class="c1">// else: remain in STATE2</span>
<span class="w">      </span><span class="k">break</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">default</span><span class="o">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="c1">// Safety net</span>
<span class="w">      </span><span class="n">state</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">INIT</span><span class="p">;</span>
<span class="w">      </span><span class="k">break</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="c1">// switch</span>
<span class="p">}</span>
</pre></div>
</div>
<p><strong>Uso:</strong> chame <code class="docutils literal notranslate"><span class="pre">ReferenceFSM_update()</span></code> em cada iteração de <code class="docutils literal notranslate"><span class="pre">loop()</span></code>.
<strong>Adaptação:</strong> substitua os temporizadores por entradas reais (botões/sensores) para materializar <code class="docutils literal notranslate"><span class="pre">event/condition_2</span></code> e <code class="docutils literal notranslate"><span class="pre">event/condition_3</span></code>.</p>
</section>
<section id="waveform-generator-fsm">
<h3>Waveform Generator FSM<a class="headerlink" href="#waveform-generator-fsm" title="Link to this heading"></a></h3>
<p><strong>Task:</strong> “Tick at a steady pace and compute the next point of the chosen wave.”</p>
<pre  class="mermaid">
        stateDiagram-v2
  [*] --&gt; INIT
  INIT --&gt; WAIT_TICK : after setup
  WAIT_TICK --&gt; COMPUTE : every sample period
  COMPUTE --&gt; WAIT_TICK : periodic waves (sine/square/saw) or ramp still running
  COMPUTE --&gt; HOLD : single ramp finished AND not repeating
  HOLD --&gt; WAIT_TICK : if restarted


    </pre><p><strong>Events:</strong> timer elapsed.
<strong>Activities:</strong> compute waveform from <code class="docutils literal notranslate"><span class="pre">phase</span> <span class="pre">=</span> <span class="pre">(now</span> <span class="pre">-</span> <span class="pre">t0)</span> <span class="pre">%</span> <span class="pre">MOD_PERIOD</span></code>.</p>
<p><strong>Code:</strong></p>
<p><a class="reference download internal" download="" href="../_downloads/154570e2dc62230a9038a3c430b7ce9c/WaveformFSM.ino"><span class="xref download myst">void WaveformFSM_update()</span></a></p>
</section>
<hr class="docutils" />
<section id="pwm-output-fsm">
<h3>PWM Output FSM<a class="headerlink" href="#pwm-output-fsm" title="Link to this heading"></a></h3>
<p><strong>Task:</strong> “At a fixed pace, update PWM for the motor; and limit how fast it changes.”</p>
<pre  class="mermaid">
        stateDiagram-v2
  [*] --&gt; INIT
  INIT --&gt; WAIT_TICK : after setup
  WAIT_TICK --&gt; UPDATE : every PWM update period
  UPDATE --&gt; WAIT_TICK : after writing PWM (with clamps &amp; slew)

    </pre><p><strong>Events:</strong> timer elapsed.
<strong>Activities:</strong> enforce <code class="docutils literal notranslate"><span class="pre">MAX_DUTY</span></code>, optional min, <strong>slew limit</strong> in logical domain; write PWM &amp; signals.</p>
<p><strong>Code:</strong></p>
<p><a class="reference download internal" download="" href="../_downloads/17a3aba8fa7e7829c2f0a6e281aebd23/PWMOutputFSM.ino"><span class="xref download myst">PWMOutputFSM_update()</span></a></p>
</section>
<hr class="docutils" />
<section id="rpm-fsm">
<h3>RPM FSM<a class="headerlink" href="#rpm-fsm" title="Link to this heading"></a></h3>
<p><strong>Task:</strong> “Open a measurement window, count pulses, compute RPM; windows can be timed or aligned with PWM updates.”</p>
<pre  class="mermaid">
        stateDiagram-v2
  [*] --&gt; INIT
  INIT --&gt; IDLE : after setup
  IDLE --&gt; START_WINDOW : MODE=coupled AND PWM updated
  IDLE --&gt; START_WINDOW : MODE=free-run AND timer elapsed
  START_WINDOW --&gt; END_WINDOW : window started
  END_WINDOW --&gt; COMPUTE : MODE=coupled AND next PWM update
  END_WINDOW --&gt; COMPUTE : MODE=free-run AND window time elapsed
  COMPUTE --&gt; IDLE : after RPM computed

    </pre><p><strong>Events:</strong> PWM edge via <code class="docutils literal notranslate"><span class="pre">sig_pwm_update_counter</span></code> (coupled) or periodic timer (free-run).
<strong>Activities:</strong> snapshot or reset pulse counter; compute RPM (guard for very short <code class="docutils literal notranslate"><span class="pre">dt</span></code>).</p>
<p><strong>Code:</strong></p>
<p><a class="reference download internal" download="" href="../_downloads/5cbb9a9761dd2592badd1d8a6375357d/RpmFSM.ino"><span class="xref download myst">void RPM_FSM_update()</span></a></p>
</section>
<hr class="docutils" />
<section id="data-logger-fsm">
<h3>Data Logger FSM<a class="headerlink" href="#data-logger-fsm" title="Link to this heading"></a></h3>
<p><strong>Task:</strong>  “Either log on a timer, or once per PWM window—only the columns you enabled.”</p>
<pre  class="mermaid">
        stateDiagram-v2
  [*] --&gt; INIT
  INIT --&gt; IDLE : after setup
  IDLE --&gt; LOG : MODE=coupled AND PWM updated
  IDLE --&gt; LOG : MODE=free-run AND log period elapsed
  LOG --&gt; IDLE : after one line printed

    </pre><p><strong>Events:</strong> PWM edge or fixed timer;
<strong>Activities:</strong> print selected fields; reprint header if layout changes.</p>
<p><strong>Code:</strong>
<a class="reference download internal" download="" href="../_downloads/e546f0e6ecc4312330a1b54958f9cbb2/DataLoggerFSM.ino"><span class="xref download myst">void DataLogger_FSM_update()</span></a></p>
</section>
<hr class="docutils" />
<section id="user-input-fsm">
<h3>User Input FSM<a class="headerlink" href="#user-input-fsm" title="Link to this heading"></a></h3>
<p><strong>Task:</strong> “Continuously read button and knob; when a full serial line arrives, parse key/value.”</p>
<pre  class="mermaid">
        stateDiagram-v2
  [*] --&gt; INIT
  INIT --&gt; WAIT_TICK : after setup
  WAIT_TICK --&gt; SCAN_INPUTS : serial data available
  SCAN_INPUTS --&gt; PARSE_LINE : end-of-line reached
  SCAN_INPUTS --&gt; WAIT_TICK : no complete line yet
  PARSE_LINE --&gt; WAIT_TICK : after key/value latched

    </pre><p><strong>Events:</strong> debounce timeout, sample timer, serial EOL.
<strong>Activities:</strong> normalize active-low button to 0/1; capture ADC; parse <code class="docutils literal notranslate"><span class="pre">char=value</span></code>.</p>
<p><strong>Code:</strong></p>
<p><a class="reference download internal" download="" href="../_downloads/bf6c954079c348af89854b01979d3069/UserInputFSM.ino"><span class="xref download myst">void UserInput_FSM_update()</span></a></p>
</section>
<hr class="docutils" />
<section id="user-output-fsm">
<h3>User Output FSM<a class="headerlink" href="#user-output-fsm" title="Link to this heading"></a></h3>
<p><strong>Task:</strong> “At a steady pace, drive LEDs; make sound via tone() or simple on/off toggling.”</p>
<pre  class="mermaid">
        stateDiagram-v2
  [*] --&gt; INIT
  INIT --&gt; WAIT_TICK : after setup
  WAIT_TICK --&gt; APPLY : every output update period
  APPLY --&gt; WAIT_TICK : after LEDs/buzzer refreshed

    </pre><p><strong>Events:</strong> timer elapsed.
<strong>Activities:</strong> <code class="docutils literal notranslate"><span class="pre">tone()</span></code> continuous/one-shot, or software toggle; active-high/low LED handling.</p>
<p><strong>Code:</strong></p>
<p><a class="reference download internal" download="" href="../_downloads/201f180e43b6bbefa03811626f4aa9c3/UserOutputFSM.ino"><span class="xref download myst">void UserOutput_FSM_update()</span></a></p>
</section>
</section>
</section>


           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, mniehus.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>