{
 "cells": [
  {
   "cell_type": "markdown",
   "id": "b16f6916",
   "metadata": {},
   "source": [
    "## Simulation"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "1c9455ee",
   "metadata": {},
   "source": [
    "This page is based on a Jupyter notebook, which is accessible through the repository. \n",
    "\n",
    "Additionally, it was exported to python source code, which can equally be downloaded and run.\n",
    "\n",
    "It is recommended to use a virtual environment and the associated requirements file.\n",
    "\n",
    "Running the jupyter/python simulation file, two graphic windows open (case they do not pop up pls check in the PC task bar and make them visible): on the left hand side, an interactive animation (with possibility to apply a perturbation torque, and to reset to initial conditions), and on the right hand side, the time series of control variables - they are updated on a click."
   ]
  },
  {
   "cell_type": "markdown",
   "id": "21cbfe23",
   "metadata": {},
   "source": [
    "### Parameters"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "id": "4336e543",
   "metadata": {},
   "outputs": [],
   "source": [
    "import numpy as np\n",
    "import math\n",
    "\n",
    "# Parameters\n",
    "# to-do: if not self-explaining, add info how to calculate or measure\n",
    "\n",
    "g = 9.81  # Gravitational acceleration (m*s^2)\n",
    "\n",
    "# Wheel parameters\n",
    "wheelradius = 0.3  # Radius of Reaction wheel (m)\n",
    "wheelheight = 0.01  # height of Reaction wheel (m)\n",
    "wheelrho=1250 # mass density of 100% infill PLA — as used in 3D printing — is typically 1.25 g/cm³ \n",
    "#m2 = 0.1  # Mass of Wheel (kg)\n",
    "m2 = 3.14*wheelradius**2*wheelheight*wheelrho  # Mass of Wheel (kg)\n",
    "#I2 = 0.0027  # Inertia moment of Wheel (Kg*m^2)\n",
    "I2 = 0.5*m2*wheelradius**2  # Inertia moment of Wheel (Kg*m^2)\n",
    "\n",
    "# DC  Motor parameters\n",
    "#would be nice to have combinations for motor1, motor2, and motor3\n",
    "motormass=0.1 #kg, ad hoc estimate\n",
    "m2 = m2+motormass  # updated\n",
    "I2 = 0.5*m2*wheelradius**2  # Inertia moment of Wheel (Kg*m^2)\n",
    "#max voltages\n",
    "#max rpm\n",
    "ke = 3.69e-2  # Electrical constant of DC Motor (Vs/rad)\n",
    "Ng = 0.83  # Transmission ratio of DC Motor\n",
    "kt = ke * Ng  # Mechanical constant of DC Motor (Nm/A)\n",
    "R = 2.85  # Resistor of DC Motor (Ohm)\n",
    "L = 3.73e-4  # Inductance of DC Motor (Henry)\n",
    "J = 0.0027  # Inertia Motor (Kgm^2)\n",
    "B = 3.85e-3  # Damping of DC Motor (Nn/v)\n",
    "#time constants\n",
    "tau_el=L/R  #electrical constant (order 0.1 ms)\n",
    "tau_mech=J/B  #mechanical constant (order 100 ms)\n",
    "# Motor Limit\n",
    "MotorLimit = True # Set to False if you don't serious about hardware Limitation\n",
    "# internal encoder ?\n",
    "# gear properties ?\n",
    "# gear ratio\n",
    "# driver properties ? PWM vs DAC ?\n",
    "# power supply ? \n",
    "\n",
    "# Pendulum parameters\n",
    "L1 = 0.5  # Length of Pendulum (from pivot to center of mass) (m)\n",
    "#L2 = 0.18  # Length of Pendulum (m)\n",
    "L2 = L1  # Length of Pendulum (m)\n",
    "#m1 = 0.1  # Mass of Pendulum (kg)\n",
    "m1 = m2  # Mass of Pendulum (kg)\n",
    "#I1 = 0.0212  # Inertia moment of Pendulum (Kg*m^2)\n",
    "I1 = m2*L1**2  # Inertia moment of Pendulum (Kg*m^2)\n",
    "dp = 0.01  # Pendulum damping constant (unit ? how to calculate, how to measure)\n",
    "\n",
    "# Sensor parameters\n",
    "\n",
    "\n",
    "#Controller parameters\n",
    "Stabilize_Controller = \"LQR\" # Select stabilize mode: \"LQR\" or \"PID\"\n",
    "StabilizeBound = 25  # Angle at which switch from Bang-bang swing up to PID/LQR starts to stabilize (degree)\n",
    "# criteria for break mode ?\n",
    "\n",
    "# Manual controller parameters?\n",
    "# some manual control wheel with some handle or so ?\n",
    "# some kinda gaming wheel as user interface ? with some haptic/manual feedback ?\n",
    "\n",
    "# Controller parameters for Bang-bang?\n",
    "# Margin ?\n",
    "\n",
    "# Controller parameters for PID\n",
    "Kp = 2143 #PID gain others ? how to calculate \n",
    "\n",
    "# Controller parameters for LQR\n",
    "Q_LQR = np.array([[342, 0, 0, 0],  # Weight for qp\n",
    "                  [0, 541, 0, 0],  # Weight for qp_d\n",
    "                  [0, 0, 1, 0],  # Weight for qr\n",
    "                  [0, 0, 0, 1]])  # Weight for qr_d    \n",
    "R_LQR = 100  # Weight for the control input\n",
    "\n",
    "N_LQR = np.array([[0],  # No cross-coupling terms for LQR\n",
    "                  [0],\n",
    "                  [0],\n",
    "                  [0]])\n",
    "\n",
    "#System parameters ?\n",
    "# Arduino ? Delay? Digitation? Memory? Speed?\n",
    "\n",
    "# Simulation configuration\n",
    "#time\n",
    "# Sound \n",
    "Sound = False # Flag to enable/disable sound\n",
    "plot_rootlocus = False # Flag to enable/disable Plot root locus\n",
    "\n",
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "id": "77951848",
   "metadata": {},
   "outputs": [],
   "source": [
    "def resetInitialState():\n",
    "    global init_qp,init_qp_d ,init_qr,init_qr_d,init_Tm,init_Tp\n",
    "    \n",
    "    # Initial state\n",
    "\n",
    "    init_qp = 180.0  # Initial pendulum angle (degree)\n",
    "    init_qp_d = 0.0  # Initial pendulum speed\n",
    "\n",
    "    init_qr = 0.0  # Initial reaction wheel angle\n",
    "    init_qr_d = 0.0  # Initial reaction wheel speed\n",
    "\n",
    "    init_Tm = 0.0  # Initial reaction wheel torque\n",
    "    init_Tp = 0.0  # Initial disturbance torque\n",
    "\n",
    "resetInitialState()\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "7272bd41",
   "metadata": {},
   "source": [
    "### Wheel simulation\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "5f22d4d4",
   "metadata": {},
   "source": [
    "### DC motor simulation\n",
    "\n",
    "Model\n",
    "\n",
    "![DC motor diagrams](../img/dcmotor.png)\n",
    "\n",
    "Parameter\n",
    "\n",
    "- `va` - Applied Voltage\n",
    "- `R` - Resistance\n",
    "- `L` - Inductance\n",
    "- `i` - Current\n",
    "- `b` - Damping coefficient\n",
    "- `J` - Rotor Inertia\n",
    "- `ke` - Back EMF constant\n",
    "- `kt` - Torque constant\n",
    "- `θ` - Rotor shaft angle\n",
    "\n",
    "Electrical part\n",
    "\n",
    "&emsp; $va = R i + L \\frac{di}{dt} + k_e \\frac{dθ}{dt}$\n",
    "\n",
    "Electromechanical Conversion\n",
    "\n",
    "&emsp; $T_{m} = k_t i$\n",
    "\n",
    "Mechanical Part\n",
    "\n",
    "&emsp; $T_{m} = b \\frac{dθ}{dt} + J\\frac{d^2θ}{dt^2}$\n",
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "id": "5ca19018",
   "metadata": {},
   "outputs": [],
   "source": [
    "def MotorDynamics(va, dt):\n",
    "    '''\n",
    "    updates dc motor torque based on input voltage and time step \n",
    "    '''\n",
    "    #global qr_d, qr, curr_prev, curr_d, curr\n",
    "    curr = (va - qr_d * ke - L * curr_d) / R\n",
    "    curr_d = (curr - curr_prev)/dt\n",
    "    Tm = curr * kt\n",
    "    qr_dd = (Tm - B * qr_d) / J\n",
    "    qr_d = qr_d + qr_dd * dt\n",
    "    qr = qr + qr_d * dt\n",
    "    curr_prev = curr\n",
    "    return Tm\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "df96540e",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Test \n",
    "import numpy as np\n",
    "import math\n",
    "import matplotlib.pyplot as plt\n",
    "\n",
    "#def runTestMotorDC():\n",
    "qr = init_qr  \n",
    "qr_d = init_qr_d  \n",
    "curr_prev = 0\n",
    "curr=0\n",
    "curr_d = 0\n",
    "\n",
    "timedt = 0  #??\n",
    "#dt = 1 / 100  # frequency (Hz)\n",
    "dt = 0.1e-3\n",
    "t_end = 1  # end time (seconds)\n",
    "t = np.arange(0, t_end + dt, dt)\n",
    "\n",
    "f = 490       # PWM frequency (Hz)\n",
    "T = 1/f       # PWM period\n",
    "duty=0.25\n",
    "TH = duty*T    # High duration (s)\n",
    "TL = T-TH      # Low duration (s)\n",
    "\n",
    "#voltage = np.where((t % T) < TH, 5, 0)  #pwm\n",
    "\n",
    "\n",
    "def simTest_motordc(t,T,TH):\n",
    "    # Initialize state variables\n",
    "    qr = 0.0\n",
    "    qr_d = 0.0\n",
    "    curr = 0.0\n",
    "    curr_prev = 0.0\n",
    "    curr_d = 0.0\n",
    "\n",
    "    t = np.arange(0, t_end+dt, dt)\n",
    "    #voltage=5*t/0.01\n",
    "    Tmm = []\n",
    "    Imm = []\n",
    "    wmm = []\n",
    "    Vmm = []\n",
    "\n",
    "    for tx in t:\n",
    "        #value = MotorDynamics(vx, dt)\n",
    "        #vx=5*tx/(t_end+dt)\n",
    "        vx = np.where((tx % T) < TH, 5, 0)  #pwm\n",
    "        #curr = (vx - qr_d * ke - L * curr_d) / R\n",
    "        #curr_d = (curr - curr_prev)/dt\n",
    "        curr_d = (vx - qr_d * ke - R * curr) / L\n",
    "        curr = curr + curr_d * dt\n",
    "        value = curr * kt\n",
    "        qr_dd = (value - B * qr_d) / J\n",
    "        qr_d = qr_d + qr_dd * dt\n",
    "        qr = qr + qr_d * dt\n",
    "        curr_prev = curr\n",
    "        Tmm.append(value)\n",
    "        wmm.append(qr_d)\n",
    "        Imm.append(curr)\n",
    "        Vmm.append(vx)\n",
    "\n",
    "    Tmm = np.array(Tmm)\n",
    "    wmm = np.array(wmm)\n",
    "    Imm = np.array(Imm)\n",
    "    Vmm = np.array(Vmm)\n",
    "\n",
    "    # Top-left: Time series input (voltage)\n",
    "    axs[0, 0].plot(t, Vmm,label=f'{TH}')\n",
    "    axs[0, 0].set_title('Applied (PWM)')\n",
    "    axs[0, 0].set_xlabel('Time (s)')\n",
    "    axs[0, 0].set_ylabel('Voltage (V)')\n",
    "    axs[0, 0].grid(True)\n",
    "\n",
    "    # Bottom-left: Time series output1 (angular velocity)\n",
    "    axs[1, 0].plot(t, wmm, label=f'{TH}')\n",
    "    axs[1, 0].set_title('Output: Angular Velocity')\n",
    "    axs[1, 0].set_xlabel('Time (s)')\n",
    "    axs[1, 0].set_ylabel('Angular Velocity (rad/s)')\n",
    "    axs[1, 0].legend()\n",
    "    axs[1, 0].grid(True)\n",
    "\n",
    "    # Top-right: Time series output2 (motor torque)\n",
    "    axs[0, 1].plot(t, Tmm, label=f'{TH}')\n",
    "    axs[0, 1].set_title('Output:Torque')\n",
    "    axs[0, 1].set_xlabel('Time (s)')\n",
    "    axs[0, 1].set_ylabel('Motor Torque (Nm)')\n",
    "    axs[0, 1].legend()\n",
    "    axs[0, 1].grid(True)\n",
    "\n",
    "    # Bottom-right: Time series output3 (current)\n",
    "    axs[1, 1].plot(t, Imm, label=f'{TH}')\n",
    "    axs[1, 1].set_title('Output: Current')\n",
    "    axs[1, 1].set_xlabel('Time (s)')\n",
    "    axs[1, 1].set_ylabel('Current (A)')\n",
    "    axs[1, 1].legend()\n",
    "    axs[1, 1].grid(True)\n",
    "\n",
    "T=1e-3\n",
    "TH=T*np.array([0.25, 0.5, 0.75])\n",
    "dt = 0.1e-3\n",
    "t_end = 1  \n",
    "t = np.arange(0, t_end, dt)\n",
    "fig, axs = plt.subplots(2, 2, figsize=(10, 8))\n",
    "for THH in TH:\n",
    "    simTest_motordc(T,THH,t)\n",
    "plt.tight_layout()\n",
    "plt.legend()\n",
    "plt.show()\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "86e592f1",
   "metadata": {},
   "source": [
    "### Simulation 1  - time series on short time scale (ms)\n",
    "- Applied voltage: \n",
    "  - 0-5 V TTL PWM\n",
    "  - PWM frqeuency f = 490 Hz or 980 Hz (typical values for Arduino PWM)\n",
    "  - Duty cycle as parameter: 25%, 50%, 75%\n",
    "- Results: \n",
    "  - Current and Torque follow the applied signal, with a lag due to the motors electrical time constant $\\t_{el}=\\frac{J}{B} \\approx 0.1 ms\n",
    "  - The amplitude of current and torque are determined by resistance and conversion coefficient\n",
    "  - The response can be classified comparing the time constants: \n",
    "    - for the pwm signal, we have period $T=1/f_{pwm}$, high time $T_H=duty \\cdot T$ , and low time $T_L=(1-duty) \\cdot T$ \n",
    "    - for the motor, we have the motors electrical time constant $t_{el}=\\frac{J}{B} \\approx 0.1 ms$\n",
    "  - The motors mechanical time constant $t_{mech}=\\frac{J}{B} \\approx 100 ms$ is not relevant on this time scale\n",
    "  - The angular velocity increases linearly over time, as expected for integration on this short time scale.\n",
    "  - It shows a ripple when pwm time constants are near to motor time constant."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "80e06060",
   "metadata": {},
   "outputs": [
    {
     "ename": "KeyboardInterrupt",
     "evalue": "",
     "output_type": "error",
     "traceback": [
      "\u001b[31m---------------------------------------------------------------------------\u001b[39m",
      "\u001b[31mKeyboardInterrupt\u001b[39m                         Traceback (most recent call last)",
      "\u001b[36mCell\u001b[39m\u001b[36m \u001b[39m\u001b[32mIn[6]\u001b[39m\u001b[32m, line 12\u001b[39m\n\u001b[32m     10\u001b[39m fig, axs = plt.subplots(\u001b[32m2\u001b[39m, \u001b[32m2\u001b[39m, figsize=(\u001b[32m10\u001b[39m, \u001b[32m8\u001b[39m))\n\u001b[32m     11\u001b[39m \u001b[38;5;28;01mfor\u001b[39;00m THH \u001b[38;5;129;01min\u001b[39;00m TH:\n\u001b[32m---> \u001b[39m\u001b[32m12\u001b[39m     \u001b[43minout\u001b[49m\u001b[43m(\u001b[49m\u001b[43mT\u001b[49m\u001b[43m,\u001b[49m\u001b[43mTHH\u001b[49m\u001b[43m,\u001b[49m\u001b[43mt\u001b[49m\u001b[43m)\u001b[49m\n\u001b[32m     13\u001b[39m plt.tight_layout()\n\u001b[32m     14\u001b[39m plt.legend()\n",
      "\u001b[36mCell\u001b[39m\u001b[36m \u001b[39m\u001b[32mIn[5]\u001b[39m\u001b[32m, line 74\u001b[39m, in \u001b[36minout\u001b[39m\u001b[34m(t, T, TH)\u001b[39m\n\u001b[32m     71\u001b[39m axs[\u001b[32m0\u001b[39m, \u001b[32m0\u001b[39m].grid(\u001b[38;5;28;01mTrue\u001b[39;00m)\n\u001b[32m     73\u001b[39m \u001b[38;5;66;03m# Bottom-left: Time series output1 (angular velocity)\u001b[39;00m\n\u001b[32m---> \u001b[39m\u001b[32m74\u001b[39m \u001b[43maxs\u001b[49m\u001b[43m[\u001b[49m\u001b[32;43m1\u001b[39;49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[32;43m0\u001b[39;49m\u001b[43m]\u001b[49m\u001b[43m.\u001b[49m\u001b[43mplot\u001b[49m\u001b[43m(\u001b[49m\u001b[43mt\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mwmm\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mlabel\u001b[49m\u001b[43m=\u001b[49m\u001b[33;43mf\u001b[39;49m\u001b[33;43m'\u001b[39;49m\u001b[38;5;132;43;01m{\u001b[39;49;00m\u001b[43mTH\u001b[49m\u001b[38;5;132;43;01m}\u001b[39;49;00m\u001b[33;43m'\u001b[39;49m\u001b[43m)\u001b[49m\n\u001b[32m     75\u001b[39m axs[\u001b[32m1\u001b[39m, \u001b[32m0\u001b[39m].set_title(\u001b[33m'\u001b[39m\u001b[33mOutput: Angular Velocity\u001b[39m\u001b[33m'\u001b[39m)\n\u001b[32m     76\u001b[39m axs[\u001b[32m1\u001b[39m, \u001b[32m0\u001b[39m].set_xlabel(\u001b[33m'\u001b[39m\u001b[33mTime (s)\u001b[39m\u001b[33m'\u001b[39m)\n",
      "\u001b[36mFile \u001b[39m\u001b[32mc:\\Users\\Utilizador\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\matplotlib\\axes\\_axes.py:1779\u001b[39m, in \u001b[36mAxes.plot\u001b[39m\u001b[34m(self, scalex, scaley, data, *args, **kwargs)\u001b[39m\n\u001b[32m   1777\u001b[39m lines = [*\u001b[38;5;28mself\u001b[39m._get_lines(\u001b[38;5;28mself\u001b[39m, *args, data=data, **kwargs)]\n\u001b[32m   1778\u001b[39m \u001b[38;5;28;01mfor\u001b[39;00m line \u001b[38;5;129;01min\u001b[39;00m lines:\n\u001b[32m-> \u001b[39m\u001b[32m1779\u001b[39m     \u001b[38;5;28;43mself\u001b[39;49m\u001b[43m.\u001b[49m\u001b[43madd_line\u001b[49m\u001b[43m(\u001b[49m\u001b[43mline\u001b[49m\u001b[43m)\u001b[49m\n\u001b[32m   1780\u001b[39m \u001b[38;5;28;01mif\u001b[39;00m scalex:\n\u001b[32m   1781\u001b[39m     \u001b[38;5;28mself\u001b[39m._request_autoscale_view(\u001b[33m\"\u001b[39m\u001b[33mx\u001b[39m\u001b[33m\"\u001b[39m)\n",
      "\u001b[36mFile \u001b[39m\u001b[32mc:\\Users\\Utilizador\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\matplotlib\\axes\\_base.py:2407\u001b[39m, in \u001b[36m_AxesBase.add_line\u001b[39m\u001b[34m(self, line)\u001b[39m\n\u001b[32m   2404\u001b[39m \u001b[38;5;28;01mif\u001b[39;00m line.get_clip_path() \u001b[38;5;129;01mis\u001b[39;00m \u001b[38;5;28;01mNone\u001b[39;00m:\n\u001b[32m   2405\u001b[39m     line.set_clip_path(\u001b[38;5;28mself\u001b[39m.patch)\n\u001b[32m-> \u001b[39m\u001b[32m2407\u001b[39m \u001b[38;5;28;43mself\u001b[39;49m\u001b[43m.\u001b[49m\u001b[43m_update_line_limits\u001b[49m\u001b[43m(\u001b[49m\u001b[43mline\u001b[49m\u001b[43m)\u001b[49m\n\u001b[32m   2408\u001b[39m \u001b[38;5;28;01mif\u001b[39;00m \u001b[38;5;129;01mnot\u001b[39;00m line.get_label():\n\u001b[32m   2409\u001b[39m     line.set_label(\u001b[33mf\u001b[39m\u001b[33m'\u001b[39m\u001b[33m_child\u001b[39m\u001b[38;5;132;01m{\u001b[39;00m\u001b[38;5;28mlen\u001b[39m(\u001b[38;5;28mself\u001b[39m._children)\u001b[38;5;132;01m}\u001b[39;00m\u001b[33m'\u001b[39m)\n",
      "\u001b[36mFile \u001b[39m\u001b[32mc:\\Users\\Utilizador\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\matplotlib\\axes\\_base.py:2430\u001b[39m, in \u001b[36m_AxesBase._update_line_limits\u001b[39m\u001b[34m(self, line)\u001b[39m\n\u001b[32m   2426\u001b[39m \u001b[38;5;28;01mdef\u001b[39;00m\u001b[38;5;250m \u001b[39m\u001b[34m_update_line_limits\u001b[39m(\u001b[38;5;28mself\u001b[39m, line):\n\u001b[32m   2427\u001b[39m \u001b[38;5;250m    \u001b[39m\u001b[33;03m\"\"\"\u001b[39;00m\n\u001b[32m   2428\u001b[39m \u001b[33;03m    Figures out the data limit of the given line, updating `.Axes.dataLim`.\u001b[39;00m\n\u001b[32m   2429\u001b[39m \u001b[33;03m    \"\"\"\u001b[39;00m\n\u001b[32m-> \u001b[39m\u001b[32m2430\u001b[39m     path = \u001b[43mline\u001b[49m\u001b[43m.\u001b[49m\u001b[43mget_path\u001b[49m\u001b[43m(\u001b[49m\u001b[43m)\u001b[49m\n\u001b[32m   2431\u001b[39m     \u001b[38;5;28;01mif\u001b[39;00m path.vertices.size == \u001b[32m0\u001b[39m:\n\u001b[32m   2432\u001b[39m         \u001b[38;5;28;01mreturn\u001b[39;00m\n",
      "\u001b[36mFile \u001b[39m\u001b[32mc:\\Users\\Utilizador\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\matplotlib\\lines.py:1052\u001b[39m, in \u001b[36mLine2D.get_path\u001b[39m\u001b[34m(self)\u001b[39m\n\u001b[32m   1050\u001b[39m \u001b[38;5;250m\u001b[39m\u001b[33;03m\"\"\"Return the `~matplotlib.path.Path` associated with this line.\"\"\"\u001b[39;00m\n\u001b[32m   1051\u001b[39m \u001b[38;5;28;01mif\u001b[39;00m \u001b[38;5;28mself\u001b[39m._invalidy \u001b[38;5;129;01mor\u001b[39;00m \u001b[38;5;28mself\u001b[39m._invalidx:\n\u001b[32m-> \u001b[39m\u001b[32m1052\u001b[39m     \u001b[38;5;28;43mself\u001b[39;49m\u001b[43m.\u001b[49m\u001b[43mrecache\u001b[49m\u001b[43m(\u001b[49m\u001b[43m)\u001b[49m\n\u001b[32m   1053\u001b[39m \u001b[38;5;28;01mreturn\u001b[39;00m \u001b[38;5;28mself\u001b[39m._path\n",
      "\u001b[36mFile \u001b[39m\u001b[32mc:\\Users\\Utilizador\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages\\matplotlib\\lines.py:711\u001b[39m, in \u001b[36mLine2D.recache\u001b[39m\u001b[34m(self, always)\u001b[39m\n\u001b[32m    702\u001b[39m \u001b[38;5;28;01mif\u001b[39;00m (\u001b[38;5;28mself\u001b[39m.axes\n\u001b[32m    703\u001b[39m         \u001b[38;5;129;01mand\u001b[39;00m \u001b[38;5;28mlen\u001b[39m(x) > \u001b[38;5;28mself\u001b[39m._subslice_optim_min_size\n\u001b[32m    704\u001b[39m         \u001b[38;5;129;01mand\u001b[39;00m _path.is_sorted_and_has_non_nan(x)\n\u001b[32m   (...)\u001b[39m\u001b[32m    708\u001b[39m         \u001b[38;5;129;01mand\u001b[39;00m \u001b[38;5;28mself\u001b[39m.get_clip_on()\n\u001b[32m    709\u001b[39m         \u001b[38;5;129;01mand\u001b[39;00m \u001b[38;5;28mself\u001b[39m.get_transform() == \u001b[38;5;28mself\u001b[39m.axes.transData):\n\u001b[32m    710\u001b[39m     \u001b[38;5;28mself\u001b[39m._subslice = \u001b[38;5;28;01mTrue\u001b[39;00m\n\u001b[32m--> \u001b[39m\u001b[32m711\u001b[39m     nanmask = \u001b[43mnp\u001b[49m\u001b[43m.\u001b[49m\u001b[43misnan\u001b[49m\u001b[43m(\u001b[49m\u001b[43mx\u001b[49m\u001b[43m)\u001b[49m\n\u001b[32m    712\u001b[39m     \u001b[38;5;28;01mif\u001b[39;00m nanmask.any():\n\u001b[32m    713\u001b[39m         \u001b[38;5;28mself\u001b[39m._x_filled = \u001b[38;5;28mself\u001b[39m._x.copy()\n",
      "\u001b[31mKeyboardInterrupt\u001b[39m: "
     ]
    }
   ],
   "source": [
    "import numpy as np\n",
    "import math\n",
    "import matplotlib.pyplot as plt\n",
    "\n",
    "T=1e-3\n",
    "TH=T*np.array([0.25, 0.5, 0.75])\n",
    "dt = 0.1e-3\n",
    "t_end = 1  \n",
    "t = np.arange(0, t_end, dt)\n",
    "fig, axs = plt.subplots(2, 2, figsize=(10, 8))\n",
    "for THH in TH:\n",
    "    simTest_motordc(T,THH,t)\n",
    "plt.tight_layout()\n",
    "plt.legend()\n",
    "plt.show()\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "a8d10987",
   "metadata": {},
   "source": [
    "### Simulation 2"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "23f778fb",
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "T=2e-3\n",
    "TH=T*np.array([0.25, 0.5, 0.75])\n",
    "dt = 0.001e-3\n",
    "t_end = 0.01  \n",
    "t = np.arange(0, t_end, dt)\n",
    "fig, axs = plt.subplots(2, 2, figsize=(10, 8))\n",
    "for THH in TH:\n",
    "    simTest_motordc(T,THH,t)\n",
    "plt.tight_layout()\n",
    "plt.legend()\n",
    "plt.show()\n",
    "\n",
    "resetInitialState()\n",
    "\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "a6261bd5",
   "metadata": {},
   "source": [
    "\n",
    "\n",
    "### Pendulum simulation\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "2089d58c",
   "metadata": {},
   "outputs": [],
   "source": [
    "def Forwardkinematics(q):\n",
    "    x = L2 * math.sin(q)\n",
    "    y = L2 * math.cos(q)\n",
    "    return x, y\n",
    "\n",
    "def PendulumEnergy(q):\n",
    "    K = (\n",
    "        (0.5 * m1 * math.pow(qp_d * L1, 2))\n",
    "        + (0.5 * m2 * math.pow(qp_d * L2, 2))\n",
    "        + (0.5 * J * qp_d * qp_d)\n",
    "        + (0.5 * I1 * qp_d * qp_d)\n",
    "    )  # Kinetic energy\n",
    "    P = (m1 + m2) * g * L2 * math.cos(q)  # Potential energy\n",
    "    return K + P\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "6a7fda92",
   "metadata": {},
   "source": [
    "\n",
    "### Sensor simulation\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "7970802f",
   "metadata": {},
   "source": [
    "\n",
    "### Controller simulation\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "61311516",
   "metadata": {},
   "outputs": [],
   "source": [
    "# LQR parameter\n",
    "a = (m1 * L1 * L1) + (m2 * L2 * L2) + (I1)\n",
    "b = (m1 * L1 + m2 * L2) * g\n",
    "\n",
    "a21 = b/a\n",
    "a24 = (kt * ke * Ng * Ng)/(a * R)\n",
    "a41 = -b/a\n",
    "a44 = -(a + J) * (kt * ke * Ng * Ng) /(a * J * R)\n",
    "\n",
    "b2 = -(kt*Ng)/(a*R)\n",
    "b4 = (a + J) * (kt * Ng)/(a * J * R)\n",
    "\n",
    "A_matrix = np.array([[0, 1, 0, 0],\n",
    "                     [a21, 0, 0, a24],\n",
    "                     [0, 0, 0, 1],\n",
    "                     [a41, 0, 0 , a44]])\n",
    "\n",
    "B_Matrix = np.array([[0],\n",
    "                     [b2],\n",
    "                     [0],\n",
    "                     [b4]])\n",
    "\n",
    "desired_poles = []\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "6bb6b722",
   "metadata": {},
   "source": [
    "\n",
    "### System simulation"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "a5f86d8a",
   "metadata": {},
   "outputs": [],
   "source": [
    "def RwipDynamics(q, Tr, Tp):\n",
    "    qdd = (\n",
    "        (m1 * g * L1 * math.sin(q)) + (m2 * g * L2 * math.sin(q)) - Tr + Tp - dp * qp_d\n",
    "    ) / ((m1 * L1**2.0) + (m2 * L2) + I1)\n",
    "    return qdd\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "0d6174e6",
   "metadata": {},
   "source": [
    "### Set up the simulator"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "765ea9cc",
   "metadata": {},
   "outputs": [],
   "source": [
    "import numpy as np\n",
    "import math\n",
    "import matplotlib.pyplot as plt\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "02f47c4f",
   "metadata": {},
   "outputs": [],
   "source": [
    "import pygame\n",
    "from pygame.locals import QUIT, MOUSEBUTTONDOWN, KEYDOWN\n",
    "import sys\n",
    "from PyQt5.QtWidgets import QApplication, QMainWindow\n",
    "from PyQt5.QtCore import Qt\n",
    "from matplotlib.backends.backend_qt5agg import FigureCanvasQTAgg as FigureCanvas\n",
    "import pygetwindow as gw\n",
    "import pyaudio\n",
    "import threading\n",
    "import control\n",
    "#import source.content.project3.code.thai.param as param  #only required when using param.py file\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "f63d38c1",
   "metadata": {},
   "source": [
    "### Visualization"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "bcc0e3b6",
   "metadata": {},
   "outputs": [],
   "source": [
    "def plot_figure(screen, qp, qp_d, qr_d, Tm, Vin, Tp, setpoint):\n",
    "    x_offset = 200\n",
    "    y_offset = 360\n",
    "    multiplier = 800\n",
    "\n",
    "    # Draw RWIP\n",
    "    x, y = Forwardkinematics(qp)\n",
    "    x, y = x_offset - x * multiplier, y_offset - y * multiplier\n",
    "    pygame.draw.line(screen, BLACK, (x_offset, y_offset), (x, y), 5)\n",
    "\n",
    "    # Draw wheel\n",
    "    pygame.draw.circle(screen, GREY, (x, y), wheelradius * multiplier, 8)\n",
    "\n",
    "    # Draw cross\n",
    "    cross_length = wheelradius * multiplier\n",
    "    cross_dx = cross_length * np.sin(qr) * 0.8\n",
    "    cross_dy = -cross_length * np.cos(qr) * 0.8\n",
    "    pygame.draw.line(\n",
    "        screen, BLACK, (x - cross_dx, y - cross_dy), (x + cross_dx, y + cross_dy), 2\n",
    "    )\n",
    "    pygame.draw.line(\n",
    "        screen, BLACK, (x - cross_dy, y + cross_dx), (x + cross_dy, y - cross_dx), 2\n",
    "    )\n",
    "\n",
    "    # Draw pendulum point\n",
    "    pygame.draw.circle(screen, BLACK, (x, y), 5)\n",
    "    pygame.draw.circle(screen, BLACK, (x_offset, y_offset), 5)\n",
    "\n",
    "    # Draw text\n",
    "    font = pygame.font.Font(None, 18)\n",
    "    texts = [\n",
    "        f\"Setpoint (deg): {round(np.rad2deg(setpoint), 2)}\",\n",
    "        f\"Pendulum Angle (deg): {round(np.rad2deg(qp), 2)}\",\n",
    "        f\"Pendulum Speed (deg/s) : {round(np.rad2deg(qp_d), 2)}\",\n",
    "        f\"Controller Mode : {controller_mode}\",\n",
    "    ]\n",
    "    for i, text in enumerate(texts):\n",
    "        rendered_text = font.render(text, True, WHITE)\n",
    "        screen.blit(rendered_text, (10, 80 + i * 20))\n",
    "    \n",
    "    texts = [\n",
    "        f\"Motorspeed (RPM): {round(qr_d * 60 / (math.pi * 2), 2)}\",\n",
    "        f\"Apply Torque (Nm): {round(Tm, 2)}\",\n",
    "        f\"Vin (V): {round(Vin, 2)}\",\n",
    "    ]\n",
    "    for i, text in enumerate(texts):\n",
    "        rendered_text = font.render(text, True, WHITE)\n",
    "        screen.blit(rendered_text, (230, 80 + i * 20))\n",
    "\n",
    "    texts = [\n",
    "        f\"FUEL: {round(controller_energy, 2)}\",\n",
    "        f\"TIME: {round(controller_time, 2)}\",\n",
    "    ]\n",
    "    for i, text in enumerate(texts):\n",
    "        rendered_text = font.render(text, True, BLACK)\n",
    "        screen.blit(rendered_text, (10, 170 + i * 20))\n",
    "\n",
    "\n",
    "def plot_graph():\n",
    "    plt.clf()\n",
    "\n",
    "    # Create the first subplot\n",
    "    plt.subplot(2, 1, 1)\n",
    "    plt.plot(timedt_data, qp_data, label=\"qp\", color=\"blue\", linewidth=2)\n",
    "    plt.plot(timedt_data, setpoint_data, label=\"setpoint\", color=\"red\", linewidth=2)\n",
    "    plt.legend()\n",
    "\n",
    "    # Create the second subplot\n",
    "    plt.subplot(2, 1, 2)\n",
    "    plt.plot(timedt_data, qr_d_data, label=\"qr_d\", color=\"purple\", linewidth=2)\n",
    "    plt.legend(loc=\"upper left\")\n",
    "    ax2 = plt.twinx()\n",
    "    ax2.plot(timedt_data, Tm_data, label=\"Tm\", color=\"green\", linewidth=2)\n",
    "    ax2.set_ylim(-1, 1)\n",
    "    ax2.legend(loc=\"upper right\")\n",
    "\n",
    "    # Display the figure\n",
    "    canvas = FigureCanvas(fig)\n",
    "    win.setCentralWidget(canvas)\n",
    "    win.show()\n",
    "\n",
    "def on_click(event):\n",
    "    plot_graph()\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "abad4678",
   "metadata": {},
   "source": [
    "### Sound (optional)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "1660bfdc",
   "metadata": {},
   "outputs": [],
   "source": [
    "p = pyaudio.PyAudio()\n",
    "BITRATE = 90000  # number of frames per second/frameset.\n",
    "FREQUENCY = 2000  # Hz, waves per second, 261.63=C4-note.\n",
    "BITRATE = max(BITRATE, FREQUENCY + 100)\n",
    "stream = p.open(format=p.get_format_from_width(1), channels=1, rate=BITRATE, output=True)\n",
    "stop_thread = False\n",
    "\n",
    "def generate_sound():\n",
    "    \"\"\"Generate and play sound with current frequency in a loop.\"\"\"\n",
    "    while not stop_thread:\n",
    "        # Generate wave data for 1 second\n",
    "        NUMBEROFFRAMES = int(BITRATE * 0.0002)  # 1 second of sound\n",
    "        WAVEDATA = \"\"\n",
    "        for x in range(NUMBEROFFRAMES):\n",
    "            try:\n",
    "                WAVEDATA += chr(int(math.sin(x / ((BITRATE / FREQUENCY) / math.pi)) * 127 + 128))\n",
    "            except ZeroDivisionError:\n",
    "                WAVEDATA += chr(128)\n",
    "        # Play sound\n",
    "        stream.write(WAVEDATA)\n",
    "\n",
    "# Start sound generation in a separate thread\n",
    "sound_thread = threading.Thread(target=generate_sound)\n",
    "#if param.Sound:\n",
    "if Sound:\n",
    "    sound_thread.start()\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "b053dc6c",
   "metadata": {},
   "source": [
    "### Run the simulator"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "25134a14",
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "# ==========================================================================================\n",
    "# ======================================= MAIN LOGIC =======================================\n",
    "# ==========================================================================================\n",
    "qp = np.deg2rad(init_qp)\n",
    "qp_d = init_qp_d\n",
    "\n",
    "qr = init_qr  # Initial reaction wheel angle\n",
    "qr_d = init_qr_d  # Initial reaction wheel speed\n",
    "\n",
    "curr_prev = 0\n",
    "curr_d = 0\n",
    "\n",
    "Tm = init_Tm  # Initial reaction wheel torque\n",
    "Tp = init_Tp  # Initial disturbance torque\n",
    "\n",
    "controller_stat_flag = False\n",
    "controller_stat_flag_last = False\n",
    "controller_time = 0\n",
    "controller_energy = 0\n",
    "\n",
    "timedt = 0\n",
    "dt = 1 / 100  # frequency (Hz)\n",
    "\n",
    "reqE = (m1 + m2) * g * L2 * math.cos(0)\n",
    "\n",
    "setpoint = 0 # do not adjust\n",
    "\n",
    "# For LQR control\n",
    "K, S, E = control.lqr(A_matrix, B_Matrix, Q_LQR, R_LQR, N_LQR)\n",
    "\n",
    "# For PID control\n",
    "s = control.TransferFunction.s\n",
    "G = (s/(-J-m1*L1*L1))/((s**3 + ((B/I1) + (B + dp)/(m2*L2*L2))*s**2 - ((m1*L1 + m2*L2)*g/((J + m2*L2*L2)*I1) - (B + dp)/((J+m2*L2*L2)*I1))*s - (m1*L1 + m2*L2)*B*g/((J+m2*L2*L2)*I1)))\n",
    "C = 1/s\n",
    "\n",
    "# Plot the root locus\n",
    "if Stabilize_Controller == \"PID\" and plot_rootlocus:\n",
    "    print(\"PID Mode\")\n",
    "    print(\"Waiting for root locus ...\")\n",
    "    print(G)\n",
    "    control.rlocus(C*G)\n",
    "    print(\"Systemzero: \", control.zero(G))\n",
    "    print(\"Systempoles: \", control.pole(G))\n",
    "    plt.title('Root Locus Plot')\n",
    "    plt.xlabel('Re')\n",
    "    plt.ylabel('Im')\n",
    "    plt.grid(True)\n",
    "    plt.show()\n",
    "    print(\"Initialize simulation\")\n",
    "\n",
    "\n",
    "d_flag = 0\n",
    "\n",
    "settled_flag = False\n",
    "wait_flag = False\n",
    "\n",
    "running = True\n",
    "input_flag = False\n",
    "input_string = \"\"\n",
    "\n",
    "pygame.init()\n",
    "\n",
    "width, height = 400, 560\n",
    "screen = pygame.display.set_mode((width, height))\n",
    "pygame.display.set_caption(\"Reaction Wheel Inverted Pendulum\")\n",
    "pygame_windows = gw.getWindowsWithTitle(\"Reaction Wheel Inverted Pendulum\")\n",
    "\n",
    "WHITE = (255, 255, 255)\n",
    "GREY = (100, 100, 100)\n",
    "RED = (255, 0, 0)\n",
    "BLACK = (0, 0, 0)\n",
    "\n",
    "font = pygame.font.Font(None, 36)\n",
    "clock = pygame.time.Clock()\n",
    "\n",
    "app = QApplication(sys.argv)\n",
    "win = QMainWindow()\n",
    "win.setWindowFlag(Qt.FramelessWindowHint)  # Remove the title bar\n",
    "fig = plt.figure(num=\"plot output\", figsize=(5, 5))\n",
    "plt.text(0, 0.4, \"Click on the pendulum display to plot.\\n\\nDon't spam, it lags.\", fontsize = 15)\n",
    "plt.axis('off')\n",
    "canvas = FigureCanvas(fig)\n",
    "win.setCentralWidget(canvas)\n",
    "win.show()\n",
    "plt.gcf().canvas.mpl_connect('button_press_event', on_click)\n",
    "\n",
    "#variable initialization\n",
    "timedt_data = []\n",
    "qp_data = []\n",
    "setpoint_data = []\n",
    "Tm_data = []\n",
    "qr_d_data = []\n",
    "\n",
    "while running:\n",
    "    for event in pygame.event.get():\n",
    "        if event.type == QUIT:  #close event\n",
    "            running = False\n",
    "        elif event.type == MOUSEBUTTONDOWN: #reset event\n",
    "            if 10 < event.pos[0] < 110 and 10 < event.pos[1] < 60:\n",
    "                input_flag = True\n",
    "            if 292 < event.pos[0] < 392 and 10 < event.pos[1] < 60:\n",
    "                qp = np.deg2rad(init_qp)\n",
    "                qp_d = init_qp_d \n",
    "                qr = init_qr\n",
    "                qr_d = init_qr_d\n",
    "                Tm = 0\n",
    "                Tp = 0\n",
    "                settled_flag = False\n",
    "                wait_flag = False\n",
    "                timedt = 0 \n",
    "                timedt_data = []\n",
    "                qp_data = []\n",
    "                setpoint_data = []\n",
    "                Tm_data = []\n",
    "                qr_d_data = []\n",
    "                controller_time = 0\n",
    "                controller_energy = 0\n",
    "            if event.pos[1] > 160:\n",
    "                plot_graph()\n",
    "        elif event.type == KEYDOWN:  #not sure what event\n",
    "            if event.key == pygame.K_BACKSPACE:\n",
    "                input_string = input_string[:-1]\n",
    "            elif event.key == pygame.K_RETURN:\n",
    "                input_flag = True\n",
    "            else:\n",
    "                input_string += event.unicode\n",
    "\n",
    "    if input_flag == True:  #event: inject external perturbation torque Tp \n",
    "        try:\n",
    "            Tp = -float(input_string)\n",
    "        except:\n",
    "            Tp = 0\n",
    "            input_string = \"\"\n",
    "        input_flag = False\n",
    "    else:\n",
    "        Tp = 0\n",
    "\n",
    "    # ==========================================================================================\n",
    "    # ======================================= Controller =======================================\n",
    "    # ==========================================================================================\n",
    "    setpoint_offset = (qp - math.pi) / (2 * math.pi) #why ?\n",
    "    if setpoint_offset < 0:\n",
    "        setpoint = (math.floor(setpoint_offset) + 1) * 2 * math.pi\n",
    "    elif setpoint_offset > 0:\n",
    "        setpoint = math.ceil(setpoint_offset) * 2 * math.pi\n",
    "    #well: would be more convenient to fold the phase\n",
    "\n",
    "    E = PendulumEnergy(q=qp)\n",
    "\n",
    "    if wait_flag:\n",
    "        controller_mode = \"brake\"\n",
    "        if abs(E) < 0.05:   #should be a parameter\n",
    "            wait_flag = False\n",
    "    elif abs(qp) % (2 * math.pi) <= np.deg2rad(StabilizeBound) or abs(qp) % (2 * math.pi) >= np.deg2rad(360 - StabilizeBound):\n",
    "        settled_flag = True\n",
    "        controller_mode = Stabilize_Controller\n",
    "        controller_stat_flag = True\n",
    "    else:\n",
    "        if settled_flag:\n",
    "            wait_flag = True\n",
    "            settled_flag = False\n",
    "        if not wait_flag:\n",
    "            controller_mode = \"Bang-bang\"\n",
    "\n",
    "    if controller_mode == \"LQR\":\n",
    "        e = setpoint - qp\n",
    "        Vin = e * K[0, 0] + qp_d * -K[0, 1]\n",
    "    elif controller_mode == \"PID\":\n",
    "        e = setpoint - qp\n",
    "        Vin = -e * Kp\n",
    "    elif controller_mode == \"Bang-bang\":\n",
    "        if (qp_d < 0 and E < reqE) or (qp_d >= 0 and E >= reqE):\n",
    "            Vin = 12\n",
    "        elif (qp_d >= 0 and E < reqE) or (qp_d < 0 and E >= reqE):\n",
    "            Vin = -12\n",
    "        else:\n",
    "            Vin = 0\n",
    "    elif controller_mode == \"brake\":\n",
    "        if qp_d < 0:\n",
    "            Vin = -12\n",
    "        elif qp_d >= 0:\n",
    "            Vin = 12\n",
    "    else:\n",
    "        Vin = 0\n",
    "    if MotorLimit:\n",
    "        # Actual Limit\n",
    "        if Vin > 24:\n",
    "            Vin = 24\n",
    "        elif Vin < -24:\n",
    "            Vin = -24\n",
    "            \n",
    "    Tm = MotorDynamics(Vin, dt)\n",
    "    FREQUENCY = pow(abs(qr_d), 2)\n",
    "    qp_dd = RwipDynamics(qp, Tm, Tp)\n",
    "    qp_d = qp_d + (qp_dd * dt)\n",
    "    qp = qp + (qp_d * dt)\n",
    "\n",
    "    # Draw background\n",
    "    screen.fill(WHITE)\n",
    "    pygame.draw.rect(screen, (24, 24, 24), (0, 0, 401, 160))\n",
    "\n",
    "    # Draw grid\n",
    "    for i in range(0, 401, 50):\n",
    "        pygame.draw.line(screen, GREY, (i, 160), (i, 600), 1)\n",
    "    for i in range(160, 560, 50):\n",
    "        pygame.draw.line(screen, GREY, (0, i), (400, i), 1)\n",
    "\n",
    "    # Draw figure\n",
    "    plot_figure(screen, qp, qp_d, qr_d, Tm, Vin, Tp, setpoint)\n",
    "    timedt_data.append(timedt)\n",
    "    qp_data.append(qp)\n",
    "    setpoint_data.append(setpoint)\n",
    "    Tm_data.append(Tm)\n",
    "    qr_d_data.append(qr_d)\n",
    "\n",
    "    # move graph with pygame\n",
    "    win.move(pygame_windows[0].left + 420, pygame_windows[0].top + 50)\n",
    "    win.showNormal()\n",
    "\n",
    "    # Draw button\n",
    "    pygame.draw.rect(screen, GREY, (10, 10, 100, 50))\n",
    "    text = font.render(\"INJECT\", True, WHITE)\n",
    "    screen.blit(text, (20, 23))\n",
    "    pygame.draw.rect(screen, RED, (292, 10, 100, 50))\n",
    "    text = font.render(\"RESET\", True, (255, 255, 255))\n",
    "    screen.blit(text, (303, 23))\n",
    "\n",
    "    # Draw disturbance input field\n",
    "    pygame.draw.rect(screen, GREY, (110, 10, 130, 50))\n",
    "    pygame.draw.rect(screen, WHITE, (125, 20, 100, 30))\n",
    "    text = font.render(input_string, True, (0, 0, 0))\n",
    "    screen.blit(text, (130, 25))\n",
    "\n",
    "    # calculate FPS and draw\n",
    "    fps = clock.get_fps()\n",
    "    timedt += dt\n",
    "    if(abs(np.rad2deg(qp) - np.rad2deg(setpoint)) < 0.1):\n",
    "        controller_stat_flag = False\n",
    "    elif(controller_stat_flag):\n",
    "        controller_time += dt\n",
    "        controller_energy += abs(qr_d * Tm) * dt\n",
    "    if(controller_mode != Stabilize_Controller or not controller_stat_flag_last and controller_stat_flag and (abs(np.rad2deg(qp) - np.rad2deg(setpoint)) < 0.1)):\n",
    "        controller_time = 0\n",
    "        controller_energy = 0\n",
    "    controller_stat_flag_last = controller_stat_flag\n",
    "    if fps:\n",
    "        dt = 1 / fps\n",
    "\n",
    "    pygame.display.flip()\n",
    "    clock.tick(165)\n",
    "\n",
    "pygame.quit()\n",
    "stop_thread = True\n",
    "sys.exit()\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "11afa77d",
   "metadata": {},
   "source": [
    "### Usage\n",
    "\n",
    "![Image of the program](https://github.com/B-Paweekorn/Reaction-wheel-inverted-pendulum/assets/47713359/e2ff45d4-bfb2-4831-9ec9-334b88f8ff77)\n",
    "\n",
    "**Inject** - Type the amount of torque into the box and click `INJECT` or ENTER key to inject a disturbance to the system\n",
    "\n",
    "**Reset** - Click `RESET` to reset the system\n",
    "\n",
    "**Plotting** - Click on the pendulum plot or the plot window to plot the data\n",
    "\n",
    "Edit the parameters in ```param.py``` (or above)S\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "d4fa36ff",
   "metadata": {},
   "source": [
    "### Example runs"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "e80f81f9",
   "metadata": {},
   "source": []
  },
  {
   "cell_type": "markdown",
   "id": "3020d451",
   "metadata": {},
   "source": [
    "### Export to python script?"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "af655bad",
   "metadata": {},
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.13.3"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
