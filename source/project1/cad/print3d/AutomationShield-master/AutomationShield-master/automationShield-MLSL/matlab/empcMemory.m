%   EMPC MEMORY ESTIMATION
%
%   This example reads requires an explicit controller object generated by
%   the Multi-Parametric Toolbox of Kvasnica et al. (mpt3.org) and outputs
%   the number of bytes required for storage in the memory. The computation
%   does not contain anything, but the storage requirements of the
%   polyhedra and the associated control laws, e.g. the real memory
%   requirement will contain the rest of your control application. This 
%   can be estimated as ~10 kB in most cases including a serial interface.

%   This code is part of the AutomationShield hardware and software
%   ecosystem. Visit http://www.automationshield.com for more
%   details. This code is licensed under a Creative Commons
%   Attribution-NonCommercial 4.0 International License.
%
%   If you have found any use of this code, please cite our work in your
%   academic publications, such as thesis, conference articles or journal
%   papers. A list of publications connected to the AutomationShield
%   project is available at: 
%   https://github.com/gergelytakacs/AutomationShield/wiki/Publications
%
%   Created by:       Gergely Takács and Martin Gulan. 
%   Created on:       9.11.2020
%   Last updated by:  Gergely Takács
%   Last update on:   9.11.2020


function memory = empcMemory(ectrl, numeric)

base = 10*1024;                % Estimate for the control loop
UNO = 32256 - base;            % Free memory for the UNO in bytes
MEGA = 253952 - base;          % Free memory for the MEGA in bytes
DUE = 524288 - base;           % Free memory for the DUE in bytes

eightBit = 1024*32/4;          % Maximal number of elements in a C array for 8 bit architectures
if numeric == 'float'
    bytes = 4;                 % 4 bytes for a single precision floating point number
elseif numeric == 'double'
    bytes = 8;                 % 8 bytes for a single precision floating point number
else
    error('Numeric type undefined.')
end    
floatsA = 0;                    % Initialize zero numbers
floatsB = 0;                    % Initialize zero numbers
floatsG = 0;                    % Initialize zero numbers
floatsF = 0;                    % Initialize zero numbers
for i = 1:ectrl.optimizer.Num  % Sweep through all partitions
        floatsA = floatsA + prod(size(ectrl.optimizer.Set(i).A));
        floatsB = floatsB + prod(size(ectrl.optimizer.Set(i).b));
        floatsF = floatsF + prod(size(ectrl.optimizer.Set(i).Functions('primal').F));
        floatsG = floatsG + prod(size(ectrl.optimizer.Set(i).Functions('primal').g));
end

if (floatsA > eightBit) || (floatsB > eightBit) || (floatsF > eightBit) || (floatsG > eightBit)
    warning('Array size not addressable in 8-bit architectures.')
end

intsNC = ectrl.optimizer.Num*4; % NC stored in full ints, but why?


floats = (floatsA+floatsB+floatsF+floatsG+intsNC);
memory = (floats*bytes);      % Number of floating point numbers*number of bytes in each of them

if memory >= UNO
    warning('This EMPC controller is unlikely to fit on the Arduino Uno.')
end

if memory >= MEGA
    warning('This EMPC controller is unlikely to fit on the Arduino Mega.')
end

if memory >= DUE
    warning('This EMPC controller is unlikely to fit on the Arduino Due.')
end


% Notes

% Max 32256
% Just sketch 444
% PGMREAD Float = 460
% Serial.begin 1438
% Control w/o = 10074
% Control w/ = 22080

% all now 11598

% Mega

% Max 253952
% Just sketch 662
% PGMREAD Float = 678
% Serial.begin 1438
